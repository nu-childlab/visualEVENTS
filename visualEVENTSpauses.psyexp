<?xml version="1.0" ?>
<PsychoPy2experiment encoding="utf-8" version="1.84.2">
  <Settings>
    <Param name="Show mouse" updates="None" val="False" valType="bool"/>
    <Param name="Data filename" updates="None" val="u'data' + os.sep + u'psychopy_data_' + data.getDateStr()" valType="code"/>
    <Param name="Monitor" updates="None" val="testMonitor" valType="str"/>
    <Param name="Enable Escape" updates="None" val="True" valType="bool"/>
    <Param name="color" updates="None" val="$[0,0,0]" valType="str"/>
    <Param name="Window size (pixels)" updates="None" val="[1366, 768]" valType="code"/>
    <Param name="Full-screen window" updates="None" val="True" valType="bool"/>
    <Param name="colorSpace" updates="None" val="rgb" valType="str"/>
    <Param name="Experiment info" updates="None" val="{u'session': u'001', u'participant': u''}" valType="code"/>
    <Param name="Save csv file" updates="None" val="False" valType="bool"/>
    <Param name="Show info dlg" updates="None" val="True" valType="bool"/>
    <Param name="Save wide csv file" updates="None" val="False" valType="bool"/>
    <Param name="Save psydat file" updates="None" val="True" valType="bool"/>
    <Param name="expName" updates="None" val="visualEVENTSpauses" valType="str"/>
    <Param name="logging level" updates="None" val="data" valType="code"/>
    <Param name="blendMode" updates="None" val="avg" valType="str"/>
    <Param name="Save excel file" updates="None" val="False" valType="bool"/>
    <Param name="Units" updates="None" val="use prefs" valType="str"/>
    <Param name="Use version" updates="None" val="" valType="str"/>
    <Param name="Save log file" updates="None" val="False" valType="bool"/>
    <Param name="Screen" updates="None" val="1" valType="num"/>
  </Settings>
  <Routines>
    <Routine name="block7">
      <CodeComponent name="code_20">
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="name" updates="None" val="code_20" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="#M3N06P&amp;#10;&amp;#10;trialClock = core.Clock()&amp;#10;from psychopy import visual,event,core&amp;#10;import time&amp;#10;import sys&amp;#10;import random&amp;#10;import csv&amp;#10;import math&amp;#10;from numpy import linspace&amp;#10;&amp;#10;win = visual.Window(size=(1366,768), fullscr = True, units = 'pix', monitor = 'testMonitor', color = [.4,.7,1],&amp;#10;    colorSpace = &quot;rgb&quot;)&amp;#10;&amp;#10;square = visual.Rect(win, lineWidth=0, fillColor=&quot;red&quot;, size=[.2,.2], pos=[-.35,0], units=&quot;height&quot;)&amp;#10;&amp;#10;numframes = 140&amp;#10;framesArray = linspace(0,(1 * math.pi),numframes)&amp;#10;count = 0&amp;#10;motion = 0&amp;#10;cycle = 0&amp;#10;left = 0&amp;#10;pauses = random.sample(range(1, 3), 1)&amp;#10;minimum = -.35&amp;#10;maximum = .35&amp;#10;while not cycle == 6:&amp;#10;    if count&gt;=(numframes):&amp;#10;        count = 0&amp;#10;        motion = 0&amp;#10;    x=framesArray[count]&amp;#10;    if ((.4 * math.tan(x)) + minimum) &gt; maximum: # CHANGE DIRECTIONS&amp;#10;        count = 0&amp;#10;        cycle += 1&amp;#10;        left += 1&amp;#10;        if motion == 0:&amp;#10;            motion = 1&amp;#10;            squarepos = maximum&amp;#10;        else:&amp;#10;            motion = 0&amp;#10;            squarepos = minimum&amp;#10;    elif motion == 1: # MOVING LEFT&amp;#10;        squarepos = maximum - (.4 * math.tan(x))&amp;#10;    else: #motion == 0 MOVING RIGHT&amp;#10;        squarepos = minimum + (.4 * math.tan(x))&amp;#10;    square.setPos([squarepos, 0])&amp;#10;    square.draw()&amp;#10;    win.flip()&amp;#10;    count += 1&amp;#10;    if (squarepos == minimum and cycle == 0) or (squarepos == minimum and cycle == 6):&amp;#10;        time.sleep(.15)&amp;#10;    if squarepos == minimum and left == pauses[0]:&amp;#10;        time.sleep(.15)&amp;#10;&amp;#10;order+=1" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
      <CodeComponent name="code_21">
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="name" updates="None" val="code_21" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="#!/usr/bin/env python&amp;#10;&amp;#10;# SUPPLIED WITH NO GUARANTEES!!&amp;#10;from psychopy import visual, core, event&amp;#10;#my lazy way of keeping time NB can be relatively inaccurate&amp;#10;import time &amp;#10;trialClock = core.Clock()&amp;#10;&amp;#10;# set up a stimulus window&amp;#10;win = visual.Window(size=(1366,768), fullscr=True,allowGUI=False,winType='pyglet',&amp;#10;            monitor='testMonitor', units ='deg', screen=0)&amp;#10;&amp;#10;#set up some fonts. If a list is provided, the first font found will be used.&amp;#10;sans = ['Gill Sans MT', 'Arial','Helvetica','Verdana']&amp;#10;&amp;#10;ResponseInstuction = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.5), text='What happened? Start typing and press return to continue.',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='white')&amp;#10;&amp;#10;#will be used to show the text they are typing: will update every &amp;#10;# time they type a letter&amp;#10;CapturedResponseString = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.07,&amp;#10;                        pos=(0, 0.0), text='',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='black')&amp;#10;&amp;#10;captured_string = '' #empty for now.. this is a string of zero length that &amp;#10;                                 # we will append our key presses to in sequence&amp;#10;&amp;#10;#a routine to save responses to file anytime we want to&amp;#10;def saveThisResponse(captured_string):&amp;#10;    outfile = &quot;./Data/visualEVENTSpauses/%s_%s_Responses.tsv&quot; %(expInfo['participant'], expName)&amp;#10;    f = open(outfile, 'a') #open our results file in append mode so we don't overwrite anything&amp;#10;    f.write('%s \t' %expInfo['participant'])&amp;#10;    f.write('%s' %order)&amp;#10;    f.write('\t')&amp;#10;    f.write('M3 \t')&amp;#10;    f.write('6 \t')&amp;#10;    f.write('1 \t')&amp;#10;    f.write('1 \t')&amp;#10;    f.write('%s' %pauses)&amp;#10;    f.write('\t')&amp;#10;    f.write(captured_string) #write the string they typed&amp;#10;    f.write('\t')&amp;#10;    f.close() #close and &quot;save&quot; the output file&amp;#10; &amp;#10;&amp;#10;#a routine to update the string on the screen as the participant types&amp;#10;def updateTheResponse(captured_string):&amp;#10;    CapturedResponseString.setText(captured_string)&amp;#10;    CapturedResponseString.draw()&amp;#10;    ResponseInstuction.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;#setup done, now start doing stuff&amp;#10;&amp;#10;# Create some handy timers&amp;#10;globalClock = core.Clock()  # to track the time since experiment started&amp;#10;routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine &amp;#10;&amp;#10;# ------Prepare to start Routine &quot;trial&quot;-------&amp;#10;t = 0&amp;#10;trialClock.reset()  # clock&amp;#10;frameN = -1&amp;#10;continueRoutine = True&amp;#10;# update component parameters for each repeat&amp;#10;&amp;#10;# keep track of which components have finished&amp;#10;trialComponents = []&amp;#10;for thisComponent in trialComponents:&amp;#10;    if hasattr(thisComponent, 'status'):&amp;#10;        thisComponent.status = NOT_STARTED&amp;#10;&amp;#10;# -------Start Routine &quot;trial&quot;-------&amp;#10;while continueRoutine:&amp;#10;    # get current time&amp;#10;    t = trialClock.getTime()&amp;#10;    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)&amp;#10;    # update/draw components on each frame&amp;#10;    &amp;#10;    &amp;#10;    # check if all components have finished&amp;#10;    if not continueRoutine:  # a component has requested a forced-end of Routine&amp;#10;        break&amp;#10;    continueRoutine = False  # will revert to True if at least one component still running&amp;#10;    for thisComponent in trialComponents:&amp;#10;        if hasattr(thisComponent, &quot;status&quot;) and thisComponent.status != FINISHED:&amp;#10;            continueRoutine = True&amp;#10;            break  # at least one component has not yet finished&amp;#10;&amp;#10;    # refresh the screen&amp;#10;    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen&amp;#10;        win.flip()&amp;#10;    #now instruct the participnat to respond&amp;#10;    ResponseInstuction.draw()  # draw instruction&amp;#10;    win.flip() # show instruction&amp;#10;    &amp;#10;    # now we will keep tracking what's happening on the keyboard&amp;#10;    # until the participant hits the return key&amp;#10;    subject_response_finished = 0 # only changes when they hit return&amp;#10;    &amp;#10;    #check for Esc key / return key presses each frame&amp;#10;    while subject_response_finished == 0:&amp;#10;        for key in event.getKeys():&amp;#10;            #quit at any point&amp;#10;            if key in ['escape']: &amp;#10;                win.close()&amp;#10;                core.quit()&amp;#10;                &amp;#10;            #if the participant hits return, save the string so far out &amp;#10;            #and reset the string to zero length for the next trial&amp;#10;            elif key in ['return']:&amp;#10;                print 'participant typed %s' %captured_string #show in debug window&amp;#10;                saveThisResponse(captured_string) #write to file&amp;#10;                captured_string = '' #reset to zero length &amp;#10;                subject_response_finished = 1 #allows the next trial to start&amp;#10;                &amp;#10;            #allow the participant to do deletions too , using the &amp;#10;            # delete key, and show the change they made&amp;#10;            elif key in ['delete','backspace']:&amp;#10;                captured_string = captured_string[:-1] #delete last character&amp;#10;                updateTheResponse(captured_string)&amp;#10;            #handle spaces&amp;#10;            elif key in ['space']:&amp;#10;                captured_string = captured_string+' '&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['period']:&amp;#10;                captured_string = captured_string+'.'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['comma']:&amp;#10;                captured_string = captured_string+','&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['apostrophe']:&amp;#10;                captured_string = captured_string+&quot;'&quot;&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['slash']:&amp;#10;                captured_string = captured_string+'/'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['semicolon']:&amp;#10;                captured_string = captured_string+';'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['bracketleft']:&amp;#10;                captured_string = captured_string+'['&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['bracketright']:&amp;#10;                captured_string = captured_string+']'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['minus']:&amp;#10;                captured_string = captured_string+'-'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['grave']:&amp;#10;                captured_string = captured_string+'`'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['equal']:&amp;#10;                captured_string = captured_string+'='&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['up','down','left','right','lshift','rshift','tab','capslock','lctrl','lalt','rctrl','ralt']:&amp;#10;                pass #do nothing when some keys are pressed&amp;#10;            #etc ...&amp;#10;&amp;#10;#if any other key is pressed, add it to the string and &amp;#10;            # show the participant what they typed&amp;#10;            else: &amp;#10;                captured_string = captured_string+key&amp;#10;                #show it&amp;#10;                updateTheResponse(captured_string)" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
      <CodeComponent name="code_22">
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="name" updates="None" val="code_22" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="#!/usr/bin/env python&amp;#10;&amp;#10;# SUPPLIED WITH NO GUARANTEES!!&amp;#10;from psychopy import visual, core, event&amp;#10;#my lazy way of keeping time NB can be relatively inaccurate&amp;#10;import time &amp;#10;&amp;#10;# set up a stimulus window&amp;#10;win = visual.Window(size=(1366,768), fullscr=True,allowGUI=False,winType='pyglet',&amp;#10;            monitor='testMonitor', units ='deg', screen=0)&amp;#10;&amp;#10;#set up some fonts. If a list is provided, the first font found will be used.&amp;#10;sans = ['Gill Sans MT', 'Arial','Helvetica','Verdana']&amp;#10;&amp;#10;ResponseInstuction = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.5), text='How many times? Please use the number keys at the top of the keyboard. Start typing and press return to continue.',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='white')&amp;#10;&amp;#10;#will be used to show the text they are typing: will update every &amp;#10;# time they type a letter&amp;#10;CapturedResponseString = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.0), text='',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='black')&amp;#10;&amp;#10;captured_string = '' #empty for now.. this is a string of zero length that &amp;#10;                                 # we will append our key presses to in sequence&amp;#10;&amp;#10;#a routine to save responses to file anytime we want to&amp;#10;def saveThisResponse(captured_string):&amp;#10;    outfile = &quot;./Data/visualEVENTSpauses/%s_%s_Responses.tsv&quot; %(expInfo['participant'], expName)&amp;#10;    f = open(outfile, 'a') #open our results file in append mode so we don't overwrite anything&amp;#10;    f.write(captured_string) #write the string they typed&amp;#10;    f.write('\n') # write a line ending&amp;#10;    f.close() #close and &quot;save&quot; the output file&amp;#10; &amp;#10;&amp;#10;#a routine to update the string on the screen as the participant types&amp;#10;def updateTheResponse(captured_string):&amp;#10;    CapturedResponseString.setText(captured_string)&amp;#10;    CapturedResponseString.draw()&amp;#10;    ResponseInstuction.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;#setup done, now start doing stuff&amp;#10;&amp;#10;# Create some handy timers&amp;#10;globalClock = core.Clock()  # to track the time since experiment started&amp;#10;routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine &amp;#10;&amp;#10;# ------Prepare to start Routine &quot;trial&quot;-------&amp;#10;t = 0&amp;#10;trialClock.reset()  # clock&amp;#10;frameN = -1&amp;#10;continueRoutine = True&amp;#10;# update component parameters for each repeat&amp;#10;&amp;#10;# keep track of which components have finished&amp;#10;trialComponents = []&amp;#10;for thisComponent in trialComponents:&amp;#10;    if hasattr(thisComponent, 'status'):&amp;#10;        thisComponent.status = NOT_STARTED&amp;#10;&amp;#10;# -------Start Routine &quot;trial&quot;-------&amp;#10;while continueRoutine:&amp;#10;    # get current time&amp;#10;    t = trialClock.getTime()&amp;#10;    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)&amp;#10;    # update/draw components on each frame&amp;#10;    &amp;#10;    &amp;#10;    # check if all components have finished&amp;#10;    if not continueRoutine:  # a component has requested a forced-end of Routine&amp;#10;        break&amp;#10;    continueRoutine = False  # will revert to True if at least one component still running&amp;#10;    for thisComponent in trialComponents:&amp;#10;        if hasattr(thisComponent, &quot;status&quot;) and thisComponent.status != FINISHED:&amp;#10;            continueRoutine = True&amp;#10;            break  # at least one component has not yet finished&amp;#10;&amp;#10;    # refresh the screen&amp;#10;    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen&amp;#10;        win.flip()&amp;#10;    #now instruct the participnat to respond&amp;#10;    ResponseInstuction.draw()  # draw instruction&amp;#10;    win.flip() # show instruction&amp;#10;    &amp;#10;    # now we will keep tracking what's happening on the keyboard&amp;#10;    # until the participant hits the return key&amp;#10;    subject_response_finished = 0 # only changes when they hit return&amp;#10;    &amp;#10;    #check for Esc key / return key presses each frame&amp;#10;    while subject_response_finished == 0:&amp;#10;        for key in event.getKeys():&amp;#10;            #quit at any point&amp;#10;            if key in ['escape']: &amp;#10;                win.close()&amp;#10;                core.quit()&amp;#10;                &amp;#10;            #if the participant hits return, save the string so far out &amp;#10;            #and reset the string to zero length for the next trial&amp;#10;            elif key in ['return']:&amp;#10;                print 'participant typed %s' %captured_string #show in debug window&amp;#10;                saveThisResponse(captured_string) #write to file&amp;#10;                captured_string = '' #reset to zero length &amp;#10;                subject_response_finished = 1 #allows the next trial to start&amp;#10;                &amp;#10;            #allow the participant to do deletions too , using the &amp;#10;            # delete key, and show the change they made&amp;#10;            elif key in ['delete','backspace']:&amp;#10;                captured_string = captured_string[:-1] #delete last character&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['up','down','left','right','lshift','rshift','tab','capslock','lctrl','lalt','rctrl','ralt', 'space', 'period', 'comma', 'apostrophe', 'slash', 'semicolon', 'bracketleft', 'bracketright', 'minus', 'grave', 'equal', 'tab', 'capslock', 'alt', 'control', 'backlash', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'z', 'x', 'c', 'v', 'b', 'n', 'm']:&amp;#10;                pass #do nothing when some keys are pressed&amp;#10;            #etc ...&amp;#10;&amp;#10;#if any other key is pressed, add it to the string and &amp;#10;            # show the participant what they typed&amp;#10;            else: &amp;#10;                captured_string = captured_string+key&amp;#10;                #show it&amp;#10;                updateTheResponse(captured_string)" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
    </Routine>
    <Routine name="block6">
      <CodeComponent name="code_17">
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="name" updates="None" val="code_17" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="#M2N18P&amp;#10;&amp;#10;trialClock = core.Clock()&amp;#10;from psychopy import visual,event,core&amp;#10;import time&amp;#10;import sys&amp;#10;import random&amp;#10;import csv&amp;#10;import math&amp;#10;from numpy import linspace&amp;#10;&amp;#10;win = visual.Window(size=(1366,768), fullscr = True, units = 'pix', monitor = 'testMonitor', color = [.4,.7,1],&amp;#10;    colorSpace = &quot;rgb&quot;)&amp;#10;&amp;#10;square = visual.Rect(win, lineWidth=0, fillColor=&quot;red&quot;, size=[.2,.2], pos=[-.35,0], units=&quot;height&quot;)&amp;#10;&amp;#10;numframes = 140&amp;#10;framesArray = linspace(0,(1 * math.pi),numframes)&amp;#10;count = 0&amp;#10;cycle = 0&amp;#10;left = 0&amp;#10;pauses = random.sample(range(1, 9), 4)&amp;#10;minimum = -.35&amp;#10;maximum = .35&amp;#10;while not cycle == 18:&amp;#10;    x=framesArray[count]&amp;#10;    if minimum &lt;= (.4 * math.tan(x)) + minimum &lt; maximum:&amp;#10;        squarepos = minimum + (.4 * math.tan(x))&amp;#10;    elif minimum &lt; (minimum + ( math.tan(x) ** (-1))) &lt;= maximum:&amp;#10;        squarepos = minimum + ( math.tan(x) ** (-1))&amp;#10;    else:&amp;#10;        count = 0&amp;#10;        cycle += 2&amp;#10;        left += 1&amp;#10;        if left == pauses [0] or left == pauses[1] or left == pauses[2] or left == pauses[3]:&amp;#10;            time.sleep(.15)&amp;#10;    square.setPos([squarepos, 0])&amp;#10;    square.draw()&amp;#10;    win.flip()&amp;#10;    count += 1&amp;#10;    if (squarepos == minimum and cycle == 0) or (squarepos == minimum and cycle == 18):&amp;#10;        time.sleep(.15)&amp;#10;&amp;#10;order+=1" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
      <CodeComponent name="code_18">
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="name" updates="None" val="code_18" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="#!/usr/bin/env python&amp;#10;&amp;#10;# SUPPLIED WITH NO GUARANTEES!!&amp;#10;from psychopy import visual, core, event&amp;#10;#my lazy way of keeping time NB can be relatively inaccurate&amp;#10;import time &amp;#10;trialClock = core.Clock()&amp;#10;&amp;#10;# set up a stimulus window&amp;#10;win = visual.Window(size=(1366,768), fullscr=True,allowGUI=False,winType='pyglet',&amp;#10;            monitor='testMonitor', units ='deg', screen=0)&amp;#10;&amp;#10;#set up some fonts. If a list is provided, the first font found will be used.&amp;#10;sans = ['Gill Sans MT', 'Arial','Helvetica','Verdana']&amp;#10;&amp;#10;ResponseInstuction = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.5), text='What happened? Start typing and press return to continue.',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='white')&amp;#10;&amp;#10;#will be used to show the text they are typing: will update every &amp;#10;# time they type a letter&amp;#10;CapturedResponseString = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.07,&amp;#10;                        pos=(0, 0.0), text='',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='black')&amp;#10;&amp;#10;captured_string = '' #empty for now.. this is a string of zero length that &amp;#10;                                 # we will append our key presses to in sequence&amp;#10;&amp;#10;#a routine to save responses to file anytime we want to&amp;#10;def saveThisResponse(captured_string):&amp;#10;    outfile = &quot;./Data/visualEVENTSpauses/%s_%s_Responses.tsv&quot; %(expInfo['participant'], expName)&amp;#10;    f = open(outfile, 'a') #open our results file in append mode so we don't overwrite anything&amp;#10;    f.write('%s \t' %expInfo['participant'])&amp;#10;    f.write('%s' %order)&amp;#10;    f.write('\t')&amp;#10;    f.write('M2 \t')&amp;#10;    f.write('18 \t')&amp;#10;    f.write('1 \t')&amp;#10;    f.write('4 \t')&amp;#10;    f.write('%s' %pauses)&amp;#10;    f.write('\t')&amp;#10;    f.write(captured_string) #write the string they typed&amp;#10;    f.write('\t')&amp;#10;    f.close() #close and &quot;save&quot; the output file&amp;#10; &amp;#10;&amp;#10;#a routine to update the string on the screen as the participant types&amp;#10;def updateTheResponse(captured_string):&amp;#10;    CapturedResponseString.setText(captured_string)&amp;#10;    CapturedResponseString.draw()&amp;#10;    ResponseInstuction.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;#setup done, now start doing stuff&amp;#10;&amp;#10;# Create some handy timers&amp;#10;globalClock = core.Clock()  # to track the time since experiment started&amp;#10;routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine &amp;#10;&amp;#10;# ------Prepare to start Routine &quot;trial&quot;-------&amp;#10;t = 0&amp;#10;trialClock.reset()  # clock&amp;#10;frameN = -1&amp;#10;continueRoutine = True&amp;#10;# update component parameters for each repeat&amp;#10;&amp;#10;# keep track of which components have finished&amp;#10;trialComponents = []&amp;#10;for thisComponent in trialComponents:&amp;#10;    if hasattr(thisComponent, 'status'):&amp;#10;        thisComponent.status = NOT_STARTED&amp;#10;&amp;#10;# -------Start Routine &quot;trial&quot;-------&amp;#10;while continueRoutine:&amp;#10;    # get current time&amp;#10;    t = trialClock.getTime()&amp;#10;    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)&amp;#10;    # update/draw components on each frame&amp;#10;    &amp;#10;    &amp;#10;    # check if all components have finished&amp;#10;    if not continueRoutine:  # a component has requested a forced-end of Routine&amp;#10;        break&amp;#10;    continueRoutine = False  # will revert to True if at least one component still running&amp;#10;    for thisComponent in trialComponents:&amp;#10;        if hasattr(thisComponent, &quot;status&quot;) and thisComponent.status != FINISHED:&amp;#10;            continueRoutine = True&amp;#10;            break  # at least one component has not yet finished&amp;#10;&amp;#10;    # refresh the screen&amp;#10;    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen&amp;#10;        win.flip()&amp;#10;    #now instruct the participnat to respond&amp;#10;    ResponseInstuction.draw()  # draw instruction&amp;#10;    win.flip() # show instruction&amp;#10;    &amp;#10;    # now we will keep tracking what's happening on the keyboard&amp;#10;    # until the participant hits the return key&amp;#10;    subject_response_finished = 0 # only changes when they hit return&amp;#10;    &amp;#10;    #check for Esc key / return key presses each frame&amp;#10;    while subject_response_finished == 0:&amp;#10;        for key in event.getKeys():&amp;#10;            #quit at any point&amp;#10;            if key in ['escape']: &amp;#10;                win.close()&amp;#10;                core.quit()&amp;#10;                &amp;#10;            #if the participant hits return, save the string so far out &amp;#10;            #and reset the string to zero length for the next trial&amp;#10;            elif key in ['return']:&amp;#10;                print 'participant typed %s' %captured_string #show in debug window&amp;#10;                saveThisResponse(captured_string) #write to file&amp;#10;                captured_string = '' #reset to zero length &amp;#10;                subject_response_finished = 1 #allows the next trial to start&amp;#10;                &amp;#10;            #allow the participant to do deletions too , using the &amp;#10;            # delete key, and show the change they made&amp;#10;            elif key in ['delete','backspace']:&amp;#10;                captured_string = captured_string[:-1] #delete last character&amp;#10;                updateTheResponse(captured_string)&amp;#10;            #handle spaces&amp;#10;            elif key in ['space']:&amp;#10;                captured_string = captured_string+' '&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['period']:&amp;#10;                captured_string = captured_string+'.'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['comma']:&amp;#10;                captured_string = captured_string+','&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['apostrophe']:&amp;#10;                captured_string = captured_string+&quot;'&quot;&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['slash']:&amp;#10;                captured_string = captured_string+'/'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['semicolon']:&amp;#10;                captured_string = captured_string+';'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['bracketleft']:&amp;#10;                captured_string = captured_string+'['&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['bracketright']:&amp;#10;                captured_string = captured_string+']'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['minus']:&amp;#10;                captured_string = captured_string+'-'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['grave']:&amp;#10;                captured_string = captured_string+'`'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['equal']:&amp;#10;                captured_string = captured_string+'='&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['up','down','left','right','lshift','rshift','tab','capslock','lctrl','lalt','rctrl','ralt']:&amp;#10;                pass #do nothing when some keys are pressed&amp;#10;            #etc ...&amp;#10;&amp;#10;#if any other key is pressed, add it to the string and &amp;#10;            # show the participant what they typed&amp;#10;            else: &amp;#10;                captured_string = captured_string+key&amp;#10;                #show it&amp;#10;                updateTheResponse(captured_string)" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
      <CodeComponent name="code_19">
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="name" updates="None" val="code_19" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="#!/usr/bin/env python&amp;#10;&amp;#10;# SUPPLIED WITH NO GUARANTEES!!&amp;#10;from psychopy import visual, core, event&amp;#10;#my lazy way of keeping time NB can be relatively inaccurate&amp;#10;import time &amp;#10;&amp;#10;# set up a stimulus window&amp;#10;win = visual.Window(size=(1366,768), fullscr=True,allowGUI=False,winType='pyglet',&amp;#10;            monitor='testMonitor', units ='deg', screen=0)&amp;#10;&amp;#10;#set up some fonts. If a list is provided, the first font found will be used.&amp;#10;sans = ['Gill Sans MT', 'Arial','Helvetica','Verdana']&amp;#10;&amp;#10;ResponseInstuction = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.5), text='How many times? Please use the number keys at the top of the keyboard. Start typing and press return to continue.',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='white')&amp;#10;&amp;#10;#will be used to show the text they are typing: will update every &amp;#10;# time they type a letter&amp;#10;CapturedResponseString = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.0), text='',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='black')&amp;#10;&amp;#10;captured_string = '' #empty for now.. this is a string of zero length that &amp;#10;                                 # we will append our key presses to in sequence&amp;#10;&amp;#10;#a routine to save responses to file anytime we want to&amp;#10;def saveThisResponse(captured_string):&amp;#10;    outfile = &quot;./Data/visualEVENTSpauses/%s_%s_Responses.tsv&quot; %(expInfo['participant'], expName)&amp;#10;    f = open(outfile, 'a') #open our results file in append mode so we don't overwrite anything&amp;#10;    f.write(captured_string) #write the string they typed&amp;#10;    f.write('\n') # write a line ending&amp;#10;    f.close() #close and &quot;save&quot; the output file&amp;#10; &amp;#10;&amp;#10;#a routine to update the string on the screen as the participant types&amp;#10;def updateTheResponse(captured_string):&amp;#10;    CapturedResponseString.setText(captured_string)&amp;#10;    CapturedResponseString.draw()&amp;#10;    ResponseInstuction.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;#setup done, now start doing stuff&amp;#10;&amp;#10;# Create some handy timers&amp;#10;globalClock = core.Clock()  # to track the time since experiment started&amp;#10;routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine &amp;#10;&amp;#10;# ------Prepare to start Routine &quot;trial&quot;-------&amp;#10;t = 0&amp;#10;trialClock.reset()  # clock&amp;#10;frameN = -1&amp;#10;continueRoutine = True&amp;#10;# update component parameters for each repeat&amp;#10;&amp;#10;# keep track of which components have finished&amp;#10;trialComponents = []&amp;#10;for thisComponent in trialComponents:&amp;#10;    if hasattr(thisComponent, 'status'):&amp;#10;        thisComponent.status = NOT_STARTED&amp;#10;&amp;#10;# -------Start Routine &quot;trial&quot;-------&amp;#10;while continueRoutine:&amp;#10;    # get current time&amp;#10;    t = trialClock.getTime()&amp;#10;    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)&amp;#10;    # update/draw components on each frame&amp;#10;    &amp;#10;    &amp;#10;    # check if all components have finished&amp;#10;    if not continueRoutine:  # a component has requested a forced-end of Routine&amp;#10;        break&amp;#10;    continueRoutine = False  # will revert to True if at least one component still running&amp;#10;    for thisComponent in trialComponents:&amp;#10;        if hasattr(thisComponent, &quot;status&quot;) and thisComponent.status != FINISHED:&amp;#10;            continueRoutine = True&amp;#10;            break  # at least one component has not yet finished&amp;#10;&amp;#10;    # refresh the screen&amp;#10;    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen&amp;#10;        win.flip()&amp;#10;    #now instruct the participnat to respond&amp;#10;    ResponseInstuction.draw()  # draw instruction&amp;#10;    win.flip() # show instruction&amp;#10;    &amp;#10;    # now we will keep tracking what's happening on the keyboard&amp;#10;    # until the participant hits the return key&amp;#10;    subject_response_finished = 0 # only changes when they hit return&amp;#10;    &amp;#10;    #check for Esc key / return key presses each frame&amp;#10;    while subject_response_finished == 0:&amp;#10;        for key in event.getKeys():&amp;#10;            #quit at any point&amp;#10;            if key in ['escape']: &amp;#10;                win.close()&amp;#10;                core.quit()&amp;#10;                &amp;#10;            #if the participant hits return, save the string so far out &amp;#10;            #and reset the string to zero length for the next trial&amp;#10;            elif key in ['return']:&amp;#10;                print 'participant typed %s' %captured_string #show in debug window&amp;#10;                saveThisResponse(captured_string) #write to file&amp;#10;                captured_string = '' #reset to zero length &amp;#10;                subject_response_finished = 1 #allows the next trial to start&amp;#10;                &amp;#10;            #allow the participant to do deletions too , using the &amp;#10;            # delete key, and show the change they made&amp;#10;            elif key in ['delete','backspace']:&amp;#10;                captured_string = captured_string[:-1] #delete last character&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['up','down','left','right','lshift','rshift','tab','capslock','lctrl','lalt','rctrl','ralt', 'space', 'period', 'comma', 'apostrophe', 'slash', 'semicolon', 'bracketleft', 'bracketright', 'minus', 'grave', 'equal', 'tab', 'capslock', 'alt', 'control', 'backlash', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'z', 'x', 'c', 'v', 'b', 'n', 'm']:&amp;#10;                pass #do nothing when some keys are pressed&amp;#10;            #etc ...&amp;#10;&amp;#10;#if any other key is pressed, add it to the string and &amp;#10;            # show the participant what they typed&amp;#10;            else: &amp;#10;                captured_string = captured_string+key&amp;#10;                #show it&amp;#10;                updateTheResponse(captured_string)" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
    </Routine>
    <Routine name="block5">
      <CodeComponent name="code_14">
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="name" updates="None" val="code_14" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="#M2N10P&amp;#10;&amp;#10;trialClock = core.Clock()&amp;#10;from psychopy import visual,event,core&amp;#10;import time&amp;#10;import sys&amp;#10;import random&amp;#10;import csv&amp;#10;import math&amp;#10;from numpy import linspace&amp;#10;&amp;#10;win = visual.Window(size=(1366,768), fullscr = True, units = 'pix', monitor = 'testMonitor', color = [.4,.7,1],&amp;#10;    colorSpace = &quot;rgb&quot;)&amp;#10;&amp;#10;square = visual.Rect(win, lineWidth=0, fillColor=&quot;red&quot;, size=[.2,.2], pos=[-.35,0], units=&quot;height&quot;)&amp;#10;&amp;#10;numframes = 140&amp;#10;framesArray = linspace(0,(1 * math.pi),numframes)&amp;#10;count = 0&amp;#10;cycle = 0&amp;#10;left = 0&amp;#10;pauses = random.sample(range(1, 5), 2)&amp;#10;minimum = -.35&amp;#10;maximum = .35&amp;#10;while not cycle == 10:&amp;#10;    x=framesArray[count]&amp;#10;    if minimum &lt;= (.4 * math.tan(x)) + minimum &lt; maximum:&amp;#10;        squarepos = minimum + (.4 * math.tan(x))&amp;#10;    elif minimum &lt; (minimum + ( math.tan(x) ** (-1))) &lt;= maximum:&amp;#10;        squarepos = minimum + ( math.tan(x) ** (-1))&amp;#10;    else:&amp;#10;        count = 0&amp;#10;        cycle += 2&amp;#10;        left += 1&amp;#10;        if left == pauses[0] or left == pauses[1]:&amp;#10;            time.sleep(.15)&amp;#10;    square.setPos([squarepos, 0])&amp;#10;    square.draw()&amp;#10;    win.flip()&amp;#10;    count += 1&amp;#10;    if (squarepos == minimum and cycle == 0) or (squarepos == minimum and cycle == 10):&amp;#10;        time.sleep(.15)&amp;#10;&amp;#10;order+=1" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
      <CodeComponent name="code_15">
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="name" updates="None" val="code_15" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="#!/usr/bin/env python&amp;#10;&amp;#10;# SUPPLIED WITH NO GUARANTEES!!&amp;#10;from psychopy import visual, core, event&amp;#10;#my lazy way of keeping time NB can be relatively inaccurate&amp;#10;import time &amp;#10;trialClock = core.Clock()&amp;#10;&amp;#10;# set up a stimulus window&amp;#10;win = visual.Window(size=(1366,768), fullscr=True,allowGUI=False,winType='pyglet',&amp;#10;            monitor='testMonitor', units ='deg', screen=0)&amp;#10;&amp;#10;#set up some fonts. If a list is provided, the first font found will be used.&amp;#10;sans = ['Gill Sans MT', 'Arial','Helvetica','Verdana']&amp;#10;&amp;#10;ResponseInstuction = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.5), text='What happened? Start typing and press return to continue.',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='white')&amp;#10;&amp;#10;#will be used to show the text they are typing: will update every &amp;#10;# time they type a letter&amp;#10;CapturedResponseString = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.07,&amp;#10;                        pos=(0, 0.0), text='',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='black')&amp;#10;&amp;#10;captured_string = '' #empty for now.. this is a string of zero length that &amp;#10;                                 # we will append our key presses to in sequence&amp;#10;&amp;#10;#a routine to save responses to file anytime we want to&amp;#10;def saveThisResponse(captured_string):&amp;#10;    outfile = &quot;./Data/visualEVENTSpauses/%s_%s_Responses.tsv&quot; %(expInfo['participant'], expName)&amp;#10;    f = open(outfile, 'a') #open our results file in append mode so we don't overwrite anything&amp;#10;    f.write('%s \t' %expInfo['participant'])&amp;#10;    f.write('%s' %order)&amp;#10;    f.write('\t')&amp;#10;    f.write('M2 \t')&amp;#10;    f.write('10 \t')&amp;#10;    f.write('1 \t')&amp;#10;    f.write('2 \t')&amp;#10;    f.write('%s' %pauses)&amp;#10;    f.write('\t')&amp;#10;    f.write(captured_string) #write the string they typed&amp;#10;    f.write('\t')&amp;#10;    f.close() #close and &quot;save&quot; the output file&amp;#10; &amp;#10;&amp;#10;#a routine to update the string on the screen as the participant types&amp;#10;def updateTheResponse(captured_string):&amp;#10;    CapturedResponseString.setText(captured_string)&amp;#10;    CapturedResponseString.draw()&amp;#10;    ResponseInstuction.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;#setup done, now start doing stuff&amp;#10;&amp;#10;# Create some handy timers&amp;#10;globalClock = core.Clock()  # to track the time since experiment started&amp;#10;routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine &amp;#10;&amp;#10;# ------Prepare to start Routine &quot;trial&quot;-------&amp;#10;t = 0&amp;#10;trialClock.reset()  # clock&amp;#10;frameN = -1&amp;#10;continueRoutine = True&amp;#10;# update component parameters for each repeat&amp;#10;&amp;#10;# keep track of which components have finished&amp;#10;trialComponents = []&amp;#10;for thisComponent in trialComponents:&amp;#10;    if hasattr(thisComponent, 'status'):&amp;#10;        thisComponent.status = NOT_STARTED&amp;#10;&amp;#10;# -------Start Routine &quot;trial&quot;-------&amp;#10;while continueRoutine:&amp;#10;    # get current time&amp;#10;    t = trialClock.getTime()&amp;#10;    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)&amp;#10;    # update/draw components on each frame&amp;#10;    &amp;#10;    &amp;#10;    # check if all components have finished&amp;#10;    if not continueRoutine:  # a component has requested a forced-end of Routine&amp;#10;        break&amp;#10;    continueRoutine = False  # will revert to True if at least one component still running&amp;#10;    for thisComponent in trialComponents:&amp;#10;        if hasattr(thisComponent, &quot;status&quot;) and thisComponent.status != FINISHED:&amp;#10;            continueRoutine = True&amp;#10;            break  # at least one component has not yet finished&amp;#10;&amp;#10;    # refresh the screen&amp;#10;    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen&amp;#10;        win.flip()&amp;#10;    #now instruct the participnat to respond&amp;#10;    ResponseInstuction.draw()  # draw instruction&amp;#10;    win.flip() # show instruction&amp;#10;    &amp;#10;    # now we will keep tracking what's happening on the keyboard&amp;#10;    # until the participant hits the return key&amp;#10;    subject_response_finished = 0 # only changes when they hit return&amp;#10;    &amp;#10;    #check for Esc key / return key presses each frame&amp;#10;    while subject_response_finished == 0:&amp;#10;        for key in event.getKeys():&amp;#10;            #quit at any point&amp;#10;            if key in ['escape']: &amp;#10;                win.close()&amp;#10;                core.quit()&amp;#10;                &amp;#10;            #if the participant hits return, save the string so far out &amp;#10;            #and reset the string to zero length for the next trial&amp;#10;            elif key in ['return']:&amp;#10;                print 'participant typed %s' %captured_string #show in debug window&amp;#10;                saveThisResponse(captured_string) #write to file&amp;#10;                captured_string = '' #reset to zero length &amp;#10;                subject_response_finished = 1 #allows the next trial to start&amp;#10;                &amp;#10;            #allow the participant to do deletions too , using the &amp;#10;            # delete key, and show the change they made&amp;#10;            elif key in ['delete','backspace']:&amp;#10;                captured_string = captured_string[:-1] #delete last character&amp;#10;                updateTheResponse(captured_string)&amp;#10;            #handle spaces&amp;#10;            elif key in ['space']:&amp;#10;                captured_string = captured_string+' '&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['period']:&amp;#10;                captured_string = captured_string+'.'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['comma']:&amp;#10;                captured_string = captured_string+','&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['apostrophe']:&amp;#10;                captured_string = captured_string+&quot;'&quot;&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['slash']:&amp;#10;                captured_string = captured_string+'/'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['semicolon']:&amp;#10;                captured_string = captured_string+';'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['bracketleft']:&amp;#10;                captured_string = captured_string+'['&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['bracketright']:&amp;#10;                captured_string = captured_string+']'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['minus']:&amp;#10;                captured_string = captured_string+'-'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['grave']:&amp;#10;                captured_string = captured_string+'`'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['equal']:&amp;#10;                captured_string = captured_string+'='&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['up','down','left','right','lshift','rshift','tab','capslock','lctrl','lalt','rctrl','ralt']:&amp;#10;                pass #do nothing when some keys are pressed&amp;#10;            #etc ...&amp;#10;&amp;#10;#if any other key is pressed, add it to the string and &amp;#10;            # show the participant what they typed&amp;#10;            else: &amp;#10;                captured_string = captured_string+key&amp;#10;                #show it&amp;#10;                updateTheResponse(captured_string)" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
      <CodeComponent name="code_16">
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="name" updates="None" val="code_16" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="#!/usr/bin/env python&amp;#10;&amp;#10;# SUPPLIED WITH NO GUARANTEES!!&amp;#10;from psychopy import visual, core, event&amp;#10;#my lazy way of keeping time NB can be relatively inaccurate&amp;#10;import time &amp;#10;&amp;#10;# set up a stimulus window&amp;#10;win = visual.Window(size=(1366,768), fullscr=True,allowGUI=False,winType='pyglet',&amp;#10;            monitor='testMonitor', units ='deg', screen=0)&amp;#10;&amp;#10;#set up some fonts. If a list is provided, the first font found will be used.&amp;#10;sans = ['Gill Sans MT', 'Arial','Helvetica','Verdana']&amp;#10;&amp;#10;ResponseInstuction = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.5), text='How many times? Please use the number keys at the top of the keyboard. Start typing and press return to continue.',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='white')&amp;#10;&amp;#10;#will be used to show the text they are typing: will update every &amp;#10;# time they type a letter&amp;#10;CapturedResponseString = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.0), text='',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='black')&amp;#10;&amp;#10;captured_string = '' #empty for now.. this is a string of zero length that &amp;#10;                                 # we will append our key presses to in sequence&amp;#10;&amp;#10;#a routine to save responses to file anytime we want to&amp;#10;def saveThisResponse(captured_string):&amp;#10;    outfile = &quot;./Data/visualEVENTSpauses/%s_%s_Responses.tsv&quot; %(expInfo['participant'], expName)&amp;#10;    f = open(outfile, 'a') #open our results file in append mode so we don't overwrite anything&amp;#10;    f.write(captured_string) #write the string they typed&amp;#10;    f.write('\n') # write a line ending&amp;#10;    f.close() #close and &quot;save&quot; the output file&amp;#10; &amp;#10;&amp;#10;#a routine to update the string on the screen as the participant types&amp;#10;def updateTheResponse(captured_string):&amp;#10;    CapturedResponseString.setText(captured_string)&amp;#10;    CapturedResponseString.draw()&amp;#10;    ResponseInstuction.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;#setup done, now start doing stuff&amp;#10;&amp;#10;# Create some handy timers&amp;#10;globalClock = core.Clock()  # to track the time since experiment started&amp;#10;routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine &amp;#10;&amp;#10;# ------Prepare to start Routine &quot;trial&quot;-------&amp;#10;t = 0&amp;#10;trialClock.reset()  # clock&amp;#10;frameN = -1&amp;#10;continueRoutine = True&amp;#10;# update component parameters for each repeat&amp;#10;&amp;#10;# keep track of which components have finished&amp;#10;trialComponents = []&amp;#10;for thisComponent in trialComponents:&amp;#10;    if hasattr(thisComponent, 'status'):&amp;#10;        thisComponent.status = NOT_STARTED&amp;#10;&amp;#10;# -------Start Routine &quot;trial&quot;-------&amp;#10;while continueRoutine:&amp;#10;    # get current time&amp;#10;    t = trialClock.getTime()&amp;#10;    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)&amp;#10;    # update/draw components on each frame&amp;#10;    &amp;#10;    &amp;#10;    # check if all components have finished&amp;#10;    if not continueRoutine:  # a component has requested a forced-end of Routine&amp;#10;        break&amp;#10;    continueRoutine = False  # will revert to True if at least one component still running&amp;#10;    for thisComponent in trialComponents:&amp;#10;        if hasattr(thisComponent, &quot;status&quot;) and thisComponent.status != FINISHED:&amp;#10;            continueRoutine = True&amp;#10;            break  # at least one component has not yet finished&amp;#10;&amp;#10;    # refresh the screen&amp;#10;    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen&amp;#10;        win.flip()&amp;#10;    #now instruct the participnat to respond&amp;#10;    ResponseInstuction.draw()  # draw instruction&amp;#10;    win.flip() # show instruction&amp;#10;    &amp;#10;    # now we will keep tracking what's happening on the keyboard&amp;#10;    # until the participant hits the return key&amp;#10;    subject_response_finished = 0 # only changes when they hit return&amp;#10;    &amp;#10;    #check for Esc key / return key presses each frame&amp;#10;    while subject_response_finished == 0:&amp;#10;        for key in event.getKeys():&amp;#10;            #quit at any point&amp;#10;            if key in ['escape']: &amp;#10;                win.close()&amp;#10;                core.quit()&amp;#10;                &amp;#10;            #if the participant hits return, save the string so far out &amp;#10;            #and reset the string to zero length for the next trial&amp;#10;            elif key in ['return']:&amp;#10;                print 'participant typed %s' %captured_string #show in debug window&amp;#10;                saveThisResponse(captured_string) #write to file&amp;#10;                captured_string = '' #reset to zero length &amp;#10;                subject_response_finished = 1 #allows the next trial to start&amp;#10;                &amp;#10;            #allow the participant to do deletions too , using the &amp;#10;            # delete key, and show the change they made&amp;#10;            elif key in ['delete','backspace']:&amp;#10;                captured_string = captured_string[:-1] #delete last character&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['up','down','left','right','lshift','rshift','tab','capslock','lctrl','lalt','rctrl','ralt', 'space', 'period', 'comma', 'apostrophe', 'slash', 'semicolon', 'bracketleft', 'bracketright', 'minus', 'grave', 'equal', 'tab', 'capslock', 'alt', 'control', 'backlash', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'z', 'x', 'c', 'v', 'b', 'n', 'm']:&amp;#10;                pass #do nothing when some keys are pressed&amp;#10;            #etc ...&amp;#10;&amp;#10;#if any other key is pressed, add it to the string and &amp;#10;            # show the participant what they typed&amp;#10;            else: &amp;#10;                captured_string = captured_string+key&amp;#10;                #show it&amp;#10;                updateTheResponse(captured_string)" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
    </Routine>
    <Routine name="block4">
      <CodeComponent name="code_11">
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="name" updates="None" val="code_11" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="#M2N06P&amp;#10;&amp;#10;trialClock = core.Clock()&amp;#10;from psychopy import visual,event,core&amp;#10;import time&amp;#10;import sys&amp;#10;import random&amp;#10;import csv&amp;#10;import math&amp;#10;from numpy import linspace&amp;#10;&amp;#10;win = visual.Window(size=(1366,768), fullscr = True, units = 'pix', monitor = 'testMonitor', color = [.4,.7,1],&amp;#10;    colorSpace = &quot;rgb&quot;)&amp;#10;&amp;#10;square = visual.Rect(win, lineWidth=0, fillColor=&quot;red&quot;, size=[.2,.2], pos=[-.35,0], units=&quot;height&quot;)&amp;#10;&amp;#10;numframes = 140&amp;#10;framesArray = linspace(0,(1 * math.pi),numframes)&amp;#10;count = 0&amp;#10;cycle = 0&amp;#10;left = 0&amp;#10;pauses = random.sample(range(1, 3), 1)&amp;#10;print pauses&amp;#10;minimum = -.35&amp;#10;maximum = .35&amp;#10;while not cycle == 6:&amp;#10;    x=framesArray[count]&amp;#10;    if minimum &lt;= (.4 * math.tan(x)) + minimum &lt; maximum:&amp;#10;        squarepos = minimum + (.4 * math.tan(x))&amp;#10;    elif minimum &lt; (minimum + ( math.tan(x) ** (-1))) &lt;= maximum:&amp;#10;        squarepos = minimum + ( math.tan(x) ** (-1))&amp;#10;    else:&amp;#10;        count = 0&amp;#10;        cycle += 2&amp;#10;        left += 1&amp;#10;        if left == pauses[0]:&amp;#10;            time.sleep(.15)&amp;#10;    square.setPos([squarepos, 0])&amp;#10;    square.draw()&amp;#10;    win.flip()&amp;#10;    count += 1&amp;#10;    if (squarepos == minimum and cycle == 0) or (squarepos == minimum and cycle == 6):&amp;#10;        time.sleep(.15)&amp;#10;&amp;#10;order+=1" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
      <CodeComponent name="code_12">
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="name" updates="None" val="code_12" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="#!/usr/bin/env python&amp;#10;&amp;#10;# SUPPLIED WITH NO GUARANTEES!!&amp;#10;from psychopy import visual, core, event&amp;#10;#my lazy way of keeping time NB can be relatively inaccurate&amp;#10;import time &amp;#10;trialClock = core.Clock()&amp;#10;&amp;#10;# set up a stimulus window&amp;#10;win = visual.Window(size=(1366,768), fullscr=True,allowGUI=False,winType='pyglet',&amp;#10;            monitor='testMonitor', units ='deg', screen=0)&amp;#10;&amp;#10;#set up some fonts. If a list is provided, the first font found will be used.&amp;#10;sans = ['Gill Sans MT', 'Arial','Helvetica','Verdana']&amp;#10;&amp;#10;ResponseInstuction = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.5), text='What happened? Start typing and press return to continue.',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='white')&amp;#10;&amp;#10;#will be used to show the text they are typing: will update every &amp;#10;# time they type a letter&amp;#10;CapturedResponseString = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.07,&amp;#10;                        pos=(0, 0.0), text='',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='black')&amp;#10;&amp;#10;captured_string = '' #empty for now.. this is a string of zero length that &amp;#10;                                 # we will append our key presses to in sequence&amp;#10;&amp;#10;#a routine to save responses to file anytime we want to&amp;#10;def saveThisResponse(captured_string):&amp;#10;    outfile = &quot;./Data/visualEVENTSpauses/%s_%s_Responses.tsv&quot; %(expInfo['participant'], expName)&amp;#10;    f = open(outfile, 'a') #open our results file in append mode so we don't overwrite anything&amp;#10;    f.write('%s \t' %expInfo['participant'])&amp;#10;    f.write('%s' %order)&amp;#10;    f.write('\t')&amp;#10;    f.write('M2 \t')&amp;#10;    f.write('6 \t')&amp;#10;    f.write('1 \t')&amp;#10;    f.write('1 \t')&amp;#10;    f.write('%s' %pauses)&amp;#10;    f.write('\t')&amp;#10;    f.write(captured_string) #write the string they typed&amp;#10;    f.write('\t')&amp;#10;    f.close() #close and &quot;save&quot; the output file&amp;#10; &amp;#10;&amp;#10;#a routine to update the string on the screen as the participant types&amp;#10;def updateTheResponse(captured_string):&amp;#10;    CapturedResponseString.setText(captured_string)&amp;#10;    CapturedResponseString.draw()&amp;#10;    ResponseInstuction.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;#setup done, now start doing stuff&amp;#10;&amp;#10;# Create some handy timers&amp;#10;globalClock = core.Clock()  # to track the time since experiment started&amp;#10;routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine &amp;#10;&amp;#10;# ------Prepare to start Routine &quot;trial&quot;-------&amp;#10;t = 0&amp;#10;trialClock.reset()  # clock&amp;#10;frameN = -1&amp;#10;continueRoutine = True&amp;#10;# update component parameters for each repeat&amp;#10;&amp;#10;# keep track of which components have finished&amp;#10;trialComponents = []&amp;#10;for thisComponent in trialComponents:&amp;#10;    if hasattr(thisComponent, 'status'):&amp;#10;        thisComponent.status = NOT_STARTED&amp;#10;&amp;#10;# -------Start Routine &quot;trial&quot;-------&amp;#10;while continueRoutine:&amp;#10;    # get current time&amp;#10;    t = trialClock.getTime()&amp;#10;    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)&amp;#10;    # update/draw components on each frame&amp;#10;    &amp;#10;    &amp;#10;    # check if all components have finished&amp;#10;    if not continueRoutine:  # a component has requested a forced-end of Routine&amp;#10;        break&amp;#10;    continueRoutine = False  # will revert to True if at least one component still running&amp;#10;    for thisComponent in trialComponents:&amp;#10;        if hasattr(thisComponent, &quot;status&quot;) and thisComponent.status != FINISHED:&amp;#10;            continueRoutine = True&amp;#10;            break  # at least one component has not yet finished&amp;#10;&amp;#10;    # refresh the screen&amp;#10;    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen&amp;#10;        win.flip()&amp;#10;    #now instruct the participnat to respond&amp;#10;    ResponseInstuction.draw()  # draw instruction&amp;#10;    win.flip() # show instruction&amp;#10;    &amp;#10;    # now we will keep tracking what's happening on the keyboard&amp;#10;    # until the participant hits the return key&amp;#10;    subject_response_finished = 0 # only changes when they hit return&amp;#10;    &amp;#10;    #check for Esc key / return key presses each frame&amp;#10;    while subject_response_finished == 0:&amp;#10;        for key in event.getKeys():&amp;#10;            #quit at any point&amp;#10;            if key in ['escape']: &amp;#10;                win.close()&amp;#10;                core.quit()&amp;#10;                &amp;#10;            #if the participant hits return, save the string so far out &amp;#10;            #and reset the string to zero length for the next trial&amp;#10;            elif key in ['return']:&amp;#10;                print 'participant typed %s' %captured_string #show in debug window&amp;#10;                saveThisResponse(captured_string) #write to file&amp;#10;                captured_string = '' #reset to zero length &amp;#10;                subject_response_finished = 1 #allows the next trial to start&amp;#10;                &amp;#10;            #allow the participant to do deletions too , using the &amp;#10;            # delete key, and show the change they made&amp;#10;            elif key in ['delete','backspace']:&amp;#10;                captured_string = captured_string[:-1] #delete last character&amp;#10;                updateTheResponse(captured_string)&amp;#10;            #handle spaces&amp;#10;            elif key in ['space']:&amp;#10;                captured_string = captured_string+' '&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['period']:&amp;#10;                captured_string = captured_string+'.'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['comma']:&amp;#10;                captured_string = captured_string+','&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['apostrophe']:&amp;#10;                captured_string = captured_string+&quot;'&quot;&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['slash']:&amp;#10;                captured_string = captured_string+'/'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['semicolon']:&amp;#10;                captured_string = captured_string+';'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['bracketleft']:&amp;#10;                captured_string = captured_string+'['&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['bracketright']:&amp;#10;                captured_string = captured_string+']'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['minus']:&amp;#10;                captured_string = captured_string+'-'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['grave']:&amp;#10;                captured_string = captured_string+'`'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['equal']:&amp;#10;                captured_string = captured_string+'='&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['up','down','left','right','lshift','rshift','tab','capslock','lctrl','lalt','rctrl','ralt']:&amp;#10;                pass #do nothing when some keys are pressed&amp;#10;            #etc ...&amp;#10;&amp;#10;#if any other key is pressed, add it to the string and &amp;#10;            # show the participant what they typed&amp;#10;            else: &amp;#10;                captured_string = captured_string+key&amp;#10;                #show it&amp;#10;                updateTheResponse(captured_string)" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
      <CodeComponent name="code_13">
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="name" updates="None" val="code_13" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="#!/usr/bin/env python&amp;#10;&amp;#10;# SUPPLIED WITH NO GUARANTEES!!&amp;#10;from psychopy import visual, core, event&amp;#10;#my lazy way of keeping time NB can be relatively inaccurate&amp;#10;import time &amp;#10;&amp;#10;# set up a stimulus window&amp;#10;win = visual.Window(size=(1366,768), fullscr=True,allowGUI=False,winType='pyglet',&amp;#10;            monitor='testMonitor', units ='deg', screen=0)&amp;#10;&amp;#10;#set up some fonts. If a list is provided, the first font found will be used.&amp;#10;sans = ['Gill Sans MT', 'Arial','Helvetica','Verdana']&amp;#10;&amp;#10;ResponseInstuction = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.5), text='How many times? Please use the number keys at the top of the keyboard. Start typing and press return to continue.',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='white')&amp;#10;&amp;#10;#will be used to show the text they are typing: will update every &amp;#10;# time they type a letter&amp;#10;CapturedResponseString = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.0), text='',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='black')&amp;#10;&amp;#10;captured_string = '' #empty for now.. this is a string of zero length that &amp;#10;                                 # we will append our key presses to in sequence&amp;#10;&amp;#10;#a routine to save responses to file anytime we want to&amp;#10;def saveThisResponse(captured_string):&amp;#10;    outfile = &quot;./Data/visualEVENTSpauses/%s_%s_Responses.tsv&quot; %(expInfo['participant'], expName)&amp;#10;    f = open(outfile, 'a') #open our results file in append mode so we don't overwrite anything&amp;#10;    f.write(captured_string) #write the string they typed&amp;#10;    f.write('\n') # write a line ending&amp;#10;    f.close() #close and &quot;save&quot; the output file&amp;#10; &amp;#10;&amp;#10;#a routine to update the string on the screen as the participant types&amp;#10;def updateTheResponse(captured_string):&amp;#10;    CapturedResponseString.setText(captured_string)&amp;#10;    CapturedResponseString.draw()&amp;#10;    ResponseInstuction.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;#setup done, now start doing stuff&amp;#10;&amp;#10;# Create some handy timers&amp;#10;globalClock = core.Clock()  # to track the time since experiment started&amp;#10;routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine &amp;#10;&amp;#10;# ------Prepare to start Routine &quot;trial&quot;-------&amp;#10;t = 0&amp;#10;trialClock.reset()  # clock&amp;#10;frameN = -1&amp;#10;continueRoutine = True&amp;#10;# update component parameters for each repeat&amp;#10;&amp;#10;# keep track of which components have finished&amp;#10;trialComponents = []&amp;#10;for thisComponent in trialComponents:&amp;#10;    if hasattr(thisComponent, 'status'):&amp;#10;        thisComponent.status = NOT_STARTED&amp;#10;&amp;#10;# -------Start Routine &quot;trial&quot;-------&amp;#10;while continueRoutine:&amp;#10;    # get current time&amp;#10;    t = trialClock.getTime()&amp;#10;    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)&amp;#10;    # update/draw components on each frame&amp;#10;    &amp;#10;    &amp;#10;    # check if all components have finished&amp;#10;    if not continueRoutine:  # a component has requested a forced-end of Routine&amp;#10;        break&amp;#10;    continueRoutine = False  # will revert to True if at least one component still running&amp;#10;    for thisComponent in trialComponents:&amp;#10;        if hasattr(thisComponent, &quot;status&quot;) and thisComponent.status != FINISHED:&amp;#10;            continueRoutine = True&amp;#10;            break  # at least one component has not yet finished&amp;#10;&amp;#10;    # refresh the screen&amp;#10;    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen&amp;#10;        win.flip()&amp;#10;    #now instruct the participnat to respond&amp;#10;    ResponseInstuction.draw()  # draw instruction&amp;#10;    win.flip() # show instruction&amp;#10;    &amp;#10;    # now we will keep tracking what's happening on the keyboard&amp;#10;    # until the participant hits the return key&amp;#10;    subject_response_finished = 0 # only changes when they hit return&amp;#10;    &amp;#10;    #check for Esc key / return key presses each frame&amp;#10;    while subject_response_finished == 0:&amp;#10;        for key in event.getKeys():&amp;#10;            #quit at any point&amp;#10;            if key in ['escape']: &amp;#10;                win.close()&amp;#10;                core.quit()&amp;#10;                &amp;#10;            #if the participant hits return, save the string so far out &amp;#10;            #and reset the string to zero length for the next trial&amp;#10;            elif key in ['return']:&amp;#10;                print 'participant typed %s' %captured_string #show in debug window&amp;#10;                saveThisResponse(captured_string) #write to file&amp;#10;                captured_string = '' #reset to zero length &amp;#10;                subject_response_finished = 1 #allows the next trial to start&amp;#10;                &amp;#10;            #allow the participant to do deletions too , using the &amp;#10;            # delete key, and show the change they made&amp;#10;            elif key in ['delete','backspace']:&amp;#10;                captured_string = captured_string[:-1] #delete last character&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['up','down','left','right','lshift','rshift','tab','capslock','lctrl','lalt','rctrl','ralt', 'space', 'period', 'comma', 'apostrophe', 'slash', 'semicolon', 'bracketleft', 'bracketright', 'minus', 'grave', 'equal', 'tab', 'capslock', 'alt', 'control', 'backlash', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'z', 'x', 'c', 'v', 'b', 'n', 'm']:&amp;#10;                pass #do nothing when some keys are pressed&amp;#10;            #etc ...&amp;#10;&amp;#10;#if any other key is pressed, add it to the string and &amp;#10;            # show the participant what they typed&amp;#10;            else: &amp;#10;                captured_string = captured_string+key&amp;#10;                #show it&amp;#10;                updateTheResponse(captured_string)" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
    </Routine>
    <Routine name="block3">
      <CodeComponent name="code_5">
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="name" updates="None" val="code_5" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="#M1N18P&amp;#10;&amp;#10;trialClock = core.Clock()&amp;#10;from psychopy import visual,event,core&amp;#10;import time&amp;#10;import sys&amp;#10;import random&amp;#10;import csv&amp;#10;import math&amp;#10;from numpy import linspace&amp;#10;&amp;#10;win = visual.Window(size=(1366,768), fullscr = True, units = 'pix', monitor = 'testMonitor', color = [.4,.7,1],&amp;#10;    colorSpace = &quot;rgb&quot;)&amp;#10;&amp;#10;square = visual.Rect(win, lineWidth=0, fillColor=&quot;red&quot;, size=[.2,.2], pos=[-.35,0], units=&quot;height&quot;)&amp;#10;&amp;#10;numframes = 140&amp;#10;framesArray = linspace(0,(2 * math.pi),numframes)&amp;#10;count = 0&amp;#10;cycle = 0&amp;#10;left = 0&amp;#10;pauses = random.sample(range(1, 9), 4)&amp;#10;minimum = -.35&amp;#10;maximum = .35&amp;#10;while not cycle == 18:&amp;#10;    if count&gt;=(numframes):&amp;#10;        count = 0&amp;#10;        cycle += 2&amp;#10;        left += 1&amp;#10;    x=framesArray[count]&amp;#10;    if (minimum + .01*(int(count))) &lt; maximum:&amp;#10;        squarepos = minimum + .01*(int(count))&amp;#10;    else:&amp;#10;        squarepos = maximum - .01*((int(count))-70)&amp;#10;    square.setPos([squarepos, 0])&amp;#10;    square.draw()&amp;#10;    win.flip()&amp;#10;    count += 1&amp;#10;    if (squarepos == minimum and cycle == 0) or (squarepos == minimum and cycle == 18):&amp;#10;        time.sleep(.15)&amp;#10;    if (squarepos == minimum and left == pauses[0]) or (squarepos == minimum and left == pauses[1]) or (squarepos == minimum and left == pauses[2]) or (squarepos == minimum and left == pauses[3]):&amp;#10;        time.sleep(.15)&amp;#10;&amp;#10;order+=1" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
      <CodeComponent name="code_9">
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="name" updates="None" val="code_9" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="#!/usr/bin/env python&amp;#10;&amp;#10;# SUPPLIED WITH NO GUARANTEES!!&amp;#10;from psychopy import visual, core, event&amp;#10;#my lazy way of keeping time NB can be relatively inaccurate&amp;#10;import time &amp;#10;trialClock = core.Clock()&amp;#10;&amp;#10;# set up a stimulus window&amp;#10;win = visual.Window(size=(1366,768), fullscr=True,allowGUI=False,winType='pyglet',&amp;#10;            monitor='testMonitor', units ='deg', screen=0)&amp;#10;&amp;#10;#set up some fonts. If a list is provided, the first font found will be used.&amp;#10;sans = ['Gill Sans MT', 'Arial','Helvetica','Verdana']&amp;#10;&amp;#10;ResponseInstuction = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.5), text='What happened? Start typing and press return to continue.',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='white')&amp;#10;&amp;#10;#will be used to show the text they are typing: will update every &amp;#10;# time they type a letter&amp;#10;CapturedResponseString = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.07,&amp;#10;                        pos=(0, 0.0), text='',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='black')&amp;#10;&amp;#10;captured_string = '' #empty for now.. this is a string of zero length that &amp;#10;                                 # we will append our key presses to in sequence&amp;#10;&amp;#10;#a routine to save responses to file anytime we want to&amp;#10;def saveThisResponse(captured_string):&amp;#10;    outfile = &quot;./Data/visualEVENTSpauses/%s_%s_Responses.tsv&quot; %(expInfo['participant'], expName)&amp;#10;    f = open(outfile, 'a') #open our results file in append mode so we don't overwrite anything&amp;#10;    f.write('%s \t' %expInfo['participant'])&amp;#10;    f.write('%s' %order)&amp;#10;    f.write('\t')&amp;#10;    f.write('M1 \t')&amp;#10;    f.write('18 \t')&amp;#10;    f.write('1 \t')&amp;#10;    f.write('4 \t')&amp;#10;    f.write('%s' %pauses)&amp;#10;    f.write('\t')&amp;#10;    f.write(captured_string) #write the string they typed&amp;#10;    f.write('\t')&amp;#10;    f.close() #close and &quot;save&quot; the output file&amp;#10; &amp;#10;&amp;#10;#a routine to update the string on the screen as the participant types&amp;#10;def updateTheResponse(captured_string):&amp;#10;    CapturedResponseString.setText(captured_string)&amp;#10;    CapturedResponseString.draw()&amp;#10;    ResponseInstuction.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;#setup done, now start doing stuff&amp;#10;&amp;#10;# Create some handy timers&amp;#10;globalClock = core.Clock()  # to track the time since experiment started&amp;#10;routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine &amp;#10;&amp;#10;# ------Prepare to start Routine &quot;trial&quot;-------&amp;#10;t = 0&amp;#10;trialClock.reset()  # clock&amp;#10;frameN = -1&amp;#10;continueRoutine = True&amp;#10;# update component parameters for each repeat&amp;#10;&amp;#10;# keep track of which components have finished&amp;#10;trialComponents = []&amp;#10;for thisComponent in trialComponents:&amp;#10;    if hasattr(thisComponent, 'status'):&amp;#10;        thisComponent.status = NOT_STARTED&amp;#10;&amp;#10;# -------Start Routine &quot;trial&quot;-------&amp;#10;while continueRoutine:&amp;#10;    # get current time&amp;#10;    t = trialClock.getTime()&amp;#10;    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)&amp;#10;    # update/draw components on each frame&amp;#10;    &amp;#10;    &amp;#10;    # check if all components have finished&amp;#10;    if not continueRoutine:  # a component has requested a forced-end of Routine&amp;#10;        break&amp;#10;    continueRoutine = False  # will revert to True if at least one component still running&amp;#10;    for thisComponent in trialComponents:&amp;#10;        if hasattr(thisComponent, &quot;status&quot;) and thisComponent.status != FINISHED:&amp;#10;            continueRoutine = True&amp;#10;            break  # at least one component has not yet finished&amp;#10;&amp;#10;    # refresh the screen&amp;#10;    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen&amp;#10;        win.flip()&amp;#10;    #now instruct the participnat to respond&amp;#10;    ResponseInstuction.draw()  # draw instruction&amp;#10;    win.flip() # show instruction&amp;#10;    &amp;#10;    # now we will keep tracking what's happening on the keyboard&amp;#10;    # until the participant hits the return key&amp;#10;    subject_response_finished = 0 # only changes when they hit return&amp;#10;    &amp;#10;    #check for Esc key / return key presses each frame&amp;#10;    while subject_response_finished == 0:&amp;#10;        for key in event.getKeys():&amp;#10;            #quit at any point&amp;#10;            if key in ['escape']: &amp;#10;                win.close()&amp;#10;                core.quit()&amp;#10;                &amp;#10;            #if the participant hits return, save the string so far out &amp;#10;            #and reset the string to zero length for the next trial&amp;#10;            elif key in ['return']:&amp;#10;                print 'participant typed %s' %captured_string #show in debug window&amp;#10;                saveThisResponse(captured_string) #write to file&amp;#10;                captured_string = '' #reset to zero length &amp;#10;                subject_response_finished = 1 #allows the next trial to start&amp;#10;                &amp;#10;            #allow the participant to do deletions too , using the &amp;#10;            # delete key, and show the change they made&amp;#10;            elif key in ['delete','backspace']:&amp;#10;                captured_string = captured_string[:-1] #delete last character&amp;#10;                updateTheResponse(captured_string)&amp;#10;            #handle spaces&amp;#10;            elif key in ['space']:&amp;#10;                captured_string = captured_string+' '&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['period']:&amp;#10;                captured_string = captured_string+'.'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['comma']:&amp;#10;                captured_string = captured_string+','&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['apostrophe']:&amp;#10;                captured_string = captured_string+&quot;'&quot;&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['slash']:&amp;#10;                captured_string = captured_string+'/'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['semicolon']:&amp;#10;                captured_string = captured_string+';'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['bracketleft']:&amp;#10;                captured_string = captured_string+'['&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['bracketright']:&amp;#10;                captured_string = captured_string+']'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['minus']:&amp;#10;                captured_string = captured_string+'-'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['grave']:&amp;#10;                captured_string = captured_string+'`'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['equal']:&amp;#10;                captured_string = captured_string+'='&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['up','down','left','right','lshift','rshift','tab','capslock','lctrl','lalt','rctrl','ralt']:&amp;#10;                pass #do nothing when some keys are pressed&amp;#10;            #etc ...&amp;#10;&amp;#10;#if any other key is pressed, add it to the string and &amp;#10;            # show the participant what they typed&amp;#10;            else: &amp;#10;                captured_string = captured_string+key&amp;#10;                #show it&amp;#10;                updateTheResponse(captured_string)" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
      <CodeComponent name="code_10">
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="name" updates="None" val="code_10" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="#!/usr/bin/env python&amp;#10;&amp;#10;# SUPPLIED WITH NO GUARANTEES!!&amp;#10;from psychopy import visual, core, event&amp;#10;#my lazy way of keeping time NB can be relatively inaccurate&amp;#10;import time &amp;#10;&amp;#10;# set up a stimulus window&amp;#10;win = visual.Window(size=(1366,768), fullscr=True,allowGUI=False,winType='pyglet',&amp;#10;            monitor='testMonitor', units ='deg', screen=0)&amp;#10;&amp;#10;#set up some fonts. If a list is provided, the first font found will be used.&amp;#10;sans = ['Gill Sans MT', 'Arial','Helvetica','Verdana']&amp;#10;&amp;#10;ResponseInstuction = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.5), text='How many times? Please use the number keys at the top of the keyboard. Start typing and press return to continue.',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='white')&amp;#10;&amp;#10;#will be used to show the text they are typing: will update every &amp;#10;# time they type a letter&amp;#10;CapturedResponseString = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.0), text='',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='black')&amp;#10;&amp;#10;captured_string = '' #empty for now.. this is a string of zero length that &amp;#10;                                 # we will append our key presses to in sequence&amp;#10;&amp;#10;#a routine to save responses to file anytime we want to&amp;#10;def saveThisResponse(captured_string):&amp;#10;    outfile = &quot;./Data/visualEVENTSpauses/%s_%s_Responses.tsv&quot; %(expInfo['participant'], expName)&amp;#10;    f = open(outfile, 'a') #open our results file in append mode so we don't overwrite anything&amp;#10;    f.write(captured_string) #write the string they typed&amp;#10;    f.write('\n') # write a line ending&amp;#10;    f.close() #close and &quot;save&quot; the output file&amp;#10; &amp;#10;&amp;#10;#a routine to update the string on the screen as the participant types&amp;#10;def updateTheResponse(captured_string):&amp;#10;    CapturedResponseString.setText(captured_string)&amp;#10;    CapturedResponseString.draw()&amp;#10;    ResponseInstuction.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;#setup done, now start doing stuff&amp;#10;&amp;#10;# Create some handy timers&amp;#10;globalClock = core.Clock()  # to track the time since experiment started&amp;#10;routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine &amp;#10;&amp;#10;# ------Prepare to start Routine &quot;trial&quot;-------&amp;#10;t = 0&amp;#10;trialClock.reset()  # clock&amp;#10;frameN = -1&amp;#10;continueRoutine = True&amp;#10;# update component parameters for each repeat&amp;#10;&amp;#10;# keep track of which components have finished&amp;#10;trialComponents = []&amp;#10;for thisComponent in trialComponents:&amp;#10;    if hasattr(thisComponent, 'status'):&amp;#10;        thisComponent.status = NOT_STARTED&amp;#10;&amp;#10;# -------Start Routine &quot;trial&quot;-------&amp;#10;while continueRoutine:&amp;#10;    # get current time&amp;#10;    t = trialClock.getTime()&amp;#10;    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)&amp;#10;    # update/draw components on each frame&amp;#10;    &amp;#10;    &amp;#10;    # check if all components have finished&amp;#10;    if not continueRoutine:  # a component has requested a forced-end of Routine&amp;#10;        break&amp;#10;    continueRoutine = False  # will revert to True if at least one component still running&amp;#10;    for thisComponent in trialComponents:&amp;#10;        if hasattr(thisComponent, &quot;status&quot;) and thisComponent.status != FINISHED:&amp;#10;            continueRoutine = True&amp;#10;            break  # at least one component has not yet finished&amp;#10;&amp;#10;    # refresh the screen&amp;#10;    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen&amp;#10;        win.flip()&amp;#10;    #now instruct the participnat to respond&amp;#10;    ResponseInstuction.draw()  # draw instruction&amp;#10;    win.flip() # show instruction&amp;#10;    &amp;#10;    # now we will keep tracking what's happening on the keyboard&amp;#10;    # until the participant hits the return key&amp;#10;    subject_response_finished = 0 # only changes when they hit return&amp;#10;    &amp;#10;    #check for Esc key / return key presses each frame&amp;#10;    while subject_response_finished == 0:&amp;#10;        for key in event.getKeys():&amp;#10;            #quit at any point&amp;#10;            if key in ['escape']: &amp;#10;                win.close()&amp;#10;                core.quit()&amp;#10;                &amp;#10;            #if the participant hits return, save the string so far out &amp;#10;            #and reset the string to zero length for the next trial&amp;#10;            elif key in ['return']:&amp;#10;                print 'participant typed %s' %captured_string #show in debug window&amp;#10;                saveThisResponse(captured_string) #write to file&amp;#10;                captured_string = '' #reset to zero length &amp;#10;                subject_response_finished = 1 #allows the next trial to start&amp;#10;                &amp;#10;            #allow the participant to do deletions too , using the &amp;#10;            # delete key, and show the change they made&amp;#10;            elif key in ['delete','backspace']:&amp;#10;                captured_string = captured_string[:-1] #delete last character&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['up','down','left','right','lshift','rshift','tab','capslock','lctrl','lalt','rctrl','ralt', 'space', 'period', 'comma', 'apostrophe', 'slash', 'semicolon', 'bracketleft', 'bracketright', 'minus', 'grave', 'equal', 'tab', 'capslock', 'alt', 'control', 'backlash', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'z', 'x', 'c', 'v', 'b', 'n', 'm']:&amp;#10;                pass #do nothing when some keys are pressed&amp;#10;            #etc ...&amp;#10;&amp;#10;#if any other key is pressed, add it to the string and &amp;#10;            # show the participant what they typed&amp;#10;            else: &amp;#10;                captured_string = captured_string+key&amp;#10;                #show it&amp;#10;                updateTheResponse(captured_string)" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
    </Routine>
    <Routine name="block2">
      <CodeComponent name="code_4">
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="name" updates="None" val="code_4" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="#M1N10P&amp;#10;&amp;#10;trialClock = core.Clock()&amp;#10;from psychopy import visual,event,core&amp;#10;import time&amp;#10;import sys&amp;#10;import random&amp;#10;import csv&amp;#10;import math&amp;#10;from numpy import linspace&amp;#10;&amp;#10;win = visual.Window(size=(1366,768), fullscr = True, units = 'pix', monitor = 'testMonitor', color = [.4,.7,1],&amp;#10;    colorSpace = &quot;rgb&quot;)&amp;#10;&amp;#10;square = visual.Rect(win, lineWidth=0, fillColor=&quot;red&quot;, size=[.2,.2], pos=[-.35,0], units=&quot;height&quot;)&amp;#10;&amp;#10;numframes = 140&amp;#10;framesArray = linspace(0,(2 * math.pi),numframes)&amp;#10;count = 0&amp;#10;cycle = 0&amp;#10;left = 0&amp;#10;pauses = random.sample(range(1, 5), 2)&amp;#10;minimum = -.35&amp;#10;maximum = .35&amp;#10;while not cycle == 10:&amp;#10;    if count&gt;=(numframes):&amp;#10;        count = 0&amp;#10;        cycle += 2&amp;#10;        left += 1&amp;#10;    x=framesArray[count]&amp;#10;    if (minimum + .01*(int(count))) &lt; maximum:&amp;#10;        squarepos = minimum + .01*(int(count))&amp;#10;    else:&amp;#10;        squarepos = maximum - .01*((int(count))-70)&amp;#10;    square.setPos([squarepos, 0])&amp;#10;    square.draw()&amp;#10;    win.flip()&amp;#10;    count += 1&amp;#10;    if (squarepos == minimum and cycle == 0) or (squarepos == minimum and cycle == 10):&amp;#10;        time.sleep(.15)&amp;#10;    if (squarepos == minimum and left == pauses[0]) or (squarepos == minimum and left == pauses[1]):&amp;#10;        time.sleep(.15)&amp;#10;&amp;#10;order+=1" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
      <CodeComponent name="code_7">
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="name" updates="None" val="code_7" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="#!/usr/bin/env python&amp;#10;&amp;#10;# SUPPLIED WITH NO GUARANTEES!!&amp;#10;from psychopy import visual, core, event&amp;#10;#my lazy way of keeping time NB can be relatively inaccurate&amp;#10;import time &amp;#10;trialClock = core.Clock()&amp;#10;&amp;#10;# set up a stimulus window&amp;#10;win = visual.Window(size=(1366,768), fullscr=True,allowGUI=False,winType='pyglet',&amp;#10;            monitor='testMonitor', units ='deg', screen=0)&amp;#10;&amp;#10;#set up some fonts. If a list is provided, the first font found will be used.&amp;#10;sans = ['Gill Sans MT', 'Arial','Helvetica','Verdana']&amp;#10;&amp;#10;ResponseInstuction = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.5), text='What happened? Start typing and press return to continue.',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='white')&amp;#10;&amp;#10;#will be used to show the text they are typing: will update every &amp;#10;# time they type a letter&amp;#10;CapturedResponseString = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.07,&amp;#10;                        pos=(0, 0.0), text='',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='black')&amp;#10;&amp;#10;captured_string = '' #empty for now.. this is a string of zero length that &amp;#10;                                 # we will append our key presses to in sequence&amp;#10;&amp;#10;#a routine to save responses to file anytime we want to&amp;#10;def saveThisResponse(captured_string):&amp;#10;    outfile = &quot;./Data/visualEVENTSpauses/%s_%s_Responses.tsv&quot; %(expInfo['participant'], expName)&amp;#10;    f = open(outfile, 'a') #open our results file in append mode so we don't overwrite anything&amp;#10;    f.write('%s \t' %expInfo['participant'])&amp;#10;    f.write('%s' %order)&amp;#10;    f.write('\t')&amp;#10;    f.write('M1 \t')&amp;#10;    f.write('10 \t')&amp;#10;    f.write('1 \t')&amp;#10;    f.write('2 \t')&amp;#10;    f.write('%s' %pauses)&amp;#10;    f.write('\t')&amp;#10;    f.write(captured_string) #write the string they typed&amp;#10;    f.write('\t')&amp;#10;    f.close() #close and &quot;save&quot; the output file&amp;#10; &amp;#10;&amp;#10;#a routine to update the string on the screen as the participant types&amp;#10;def updateTheResponse(captured_string):&amp;#10;    CapturedResponseString.setText(captured_string)&amp;#10;    CapturedResponseString.draw()&amp;#10;    ResponseInstuction.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;#setup done, now start doing stuff&amp;#10;&amp;#10;# Create some handy timers&amp;#10;globalClock = core.Clock()  # to track the time since experiment started&amp;#10;routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine &amp;#10;&amp;#10;# ------Prepare to start Routine &quot;trial&quot;-------&amp;#10;t = 0&amp;#10;trialClock.reset()  # clock&amp;#10;frameN = -1&amp;#10;continueRoutine = True&amp;#10;# update component parameters for each repeat&amp;#10;&amp;#10;# keep track of which components have finished&amp;#10;trialComponents = []&amp;#10;for thisComponent in trialComponents:&amp;#10;    if hasattr(thisComponent, 'status'):&amp;#10;        thisComponent.status = NOT_STARTED&amp;#10;&amp;#10;# -------Start Routine &quot;trial&quot;-------&amp;#10;while continueRoutine:&amp;#10;    # get current time&amp;#10;    t = trialClock.getTime()&amp;#10;    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)&amp;#10;    # update/draw components on each frame&amp;#10;    &amp;#10;    &amp;#10;    # check if all components have finished&amp;#10;    if not continueRoutine:  # a component has requested a forced-end of Routine&amp;#10;        break&amp;#10;    continueRoutine = False  # will revert to True if at least one component still running&amp;#10;    for thisComponent in trialComponents:&amp;#10;        if hasattr(thisComponent, &quot;status&quot;) and thisComponent.status != FINISHED:&amp;#10;            continueRoutine = True&amp;#10;            break  # at least one component has not yet finished&amp;#10;&amp;#10;    # refresh the screen&amp;#10;    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen&amp;#10;        win.flip()&amp;#10;    #now instruct the participnat to respond&amp;#10;    ResponseInstuction.draw()  # draw instruction&amp;#10;    win.flip() # show instruction&amp;#10;    &amp;#10;    # now we will keep tracking what's happening on the keyboard&amp;#10;    # until the participant hits the return key&amp;#10;    subject_response_finished = 0 # only changes when they hit return&amp;#10;    &amp;#10;    #check for Esc key / return key presses each frame&amp;#10;    while subject_response_finished == 0:&amp;#10;        for key in event.getKeys():&amp;#10;            #quit at any point&amp;#10;            if key in ['escape']: &amp;#10;                win.close()&amp;#10;                core.quit()&amp;#10;                &amp;#10;            #if the participant hits return, save the string so far out &amp;#10;            #and reset the string to zero length for the next trial&amp;#10;            elif key in ['return']:&amp;#10;                print 'participant typed %s' %captured_string #show in debug window&amp;#10;                saveThisResponse(captured_string) #write to file&amp;#10;                captured_string = '' #reset to zero length &amp;#10;                subject_response_finished = 1 #allows the next trial to start&amp;#10;                &amp;#10;            #allow the participant to do deletions too , using the &amp;#10;            # delete key, and show the change they made&amp;#10;            elif key in ['delete','backspace']:&amp;#10;                captured_string = captured_string[:-1] #delete last character&amp;#10;                updateTheResponse(captured_string)&amp;#10;            #handle spaces&amp;#10;            elif key in ['space']:&amp;#10;                captured_string = captured_string+' '&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['period']:&amp;#10;                captured_string = captured_string+'.'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['comma']:&amp;#10;                captured_string = captured_string+','&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['apostrophe']:&amp;#10;                captured_string = captured_string+&quot;'&quot;&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['slash']:&amp;#10;                captured_string = captured_string+'/'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['semicolon']:&amp;#10;                captured_string = captured_string+';'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['bracketleft']:&amp;#10;                captured_string = captured_string+'['&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['bracketright']:&amp;#10;                captured_string = captured_string+']'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['minus']:&amp;#10;                captured_string = captured_string+'-'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['grave']:&amp;#10;                captured_string = captured_string+'`'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['equal']:&amp;#10;                captured_string = captured_string+'='&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['up','down','left','right','lshift','rshift','tab','capslock','lctrl','lalt','rctrl','ralt']:&amp;#10;                pass #do nothing when some keys are pressed&amp;#10;            #etc ...&amp;#10;&amp;#10;#if any other key is pressed, add it to the string and &amp;#10;            # show the participant what they typed&amp;#10;            else: &amp;#10;                captured_string = captured_string+key&amp;#10;                #show it&amp;#10;                updateTheResponse(captured_string)" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
      <CodeComponent name="code_8">
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="name" updates="None" val="code_8" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="#!/usr/bin/env python&amp;#10;&amp;#10;# SUPPLIED WITH NO GUARANTEES!!&amp;#10;from psychopy import visual, core, event&amp;#10;#my lazy way of keeping time NB can be relatively inaccurate&amp;#10;import time &amp;#10;&amp;#10;# set up a stimulus window&amp;#10;win = visual.Window(size=(1366,768), fullscr=True,allowGUI=False,winType='pyglet',&amp;#10;            monitor='testMonitor', units ='deg', screen=0)&amp;#10;&amp;#10;#set up some fonts. If a list is provided, the first font found will be used.&amp;#10;sans = ['Gill Sans MT', 'Arial','Helvetica','Verdana']&amp;#10;&amp;#10;ResponseInstuction = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.5), text='How many times? Please use the number keys at the top of the keyboard. Start typing and press return to continue.',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='white')&amp;#10;&amp;#10;#will be used to show the text they are typing: will update every &amp;#10;# time they type a letter&amp;#10;CapturedResponseString = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.0), text='',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='black')&amp;#10;&amp;#10;captured_string = '' #empty for now.. this is a string of zero length that &amp;#10;                                 # we will append our key presses to in sequence&amp;#10;&amp;#10;#a routine to save responses to file anytime we want to&amp;#10;def saveThisResponse(captured_string):&amp;#10;    outfile = &quot;./Data/visualEVENTSpauses/%s_%s_Responses.tsv&quot; %(expInfo['participant'], expName)&amp;#10;    f = open(outfile, 'a') #open our results file in append mode so we don't overwrite anything&amp;#10;    f.write(captured_string) #write the string they typed&amp;#10;    f.write('\n') # write a line ending&amp;#10;    f.close() #close and &quot;save&quot; the output file&amp;#10; &amp;#10;&amp;#10;#a routine to update the string on the screen as the participant types&amp;#10;def updateTheResponse(captured_string):&amp;#10;    CapturedResponseString.setText(captured_string)&amp;#10;    CapturedResponseString.draw()&amp;#10;    ResponseInstuction.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;#setup done, now start doing stuff&amp;#10;&amp;#10;# Create some handy timers&amp;#10;globalClock = core.Clock()  # to track the time since experiment started&amp;#10;routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine &amp;#10;&amp;#10;# ------Prepare to start Routine &quot;trial&quot;-------&amp;#10;t = 0&amp;#10;trialClock.reset()  # clock&amp;#10;frameN = -1&amp;#10;continueRoutine = True&amp;#10;# update component parameters for each repeat&amp;#10;&amp;#10;# keep track of which components have finished&amp;#10;trialComponents = []&amp;#10;for thisComponent in trialComponents:&amp;#10;    if hasattr(thisComponent, 'status'):&amp;#10;        thisComponent.status = NOT_STARTED&amp;#10;&amp;#10;# -------Start Routine &quot;trial&quot;-------&amp;#10;while continueRoutine:&amp;#10;    # get current time&amp;#10;    t = trialClock.getTime()&amp;#10;    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)&amp;#10;    # update/draw components on each frame&amp;#10;    &amp;#10;    &amp;#10;    # check if all components have finished&amp;#10;    if not continueRoutine:  # a component has requested a forced-end of Routine&amp;#10;        break&amp;#10;    continueRoutine = False  # will revert to True if at least one component still running&amp;#10;    for thisComponent in trialComponents:&amp;#10;        if hasattr(thisComponent, &quot;status&quot;) and thisComponent.status != FINISHED:&amp;#10;            continueRoutine = True&amp;#10;            break  # at least one component has not yet finished&amp;#10;&amp;#10;    # refresh the screen&amp;#10;    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen&amp;#10;        win.flip()&amp;#10;    #now instruct the participnat to respond&amp;#10;    ResponseInstuction.draw()  # draw instruction&amp;#10;    win.flip() # show instruction&amp;#10;    &amp;#10;    # now we will keep tracking what's happening on the keyboard&amp;#10;    # until the participant hits the return key&amp;#10;    subject_response_finished = 0 # only changes when they hit return&amp;#10;    &amp;#10;    #check for Esc key / return key presses each frame&amp;#10;    while subject_response_finished == 0:&amp;#10;        for key in event.getKeys():&amp;#10;            #quit at any point&amp;#10;            if key in ['escape']: &amp;#10;                win.close()&amp;#10;                core.quit()&amp;#10;                &amp;#10;            #if the participant hits return, save the string so far out &amp;#10;            #and reset the string to zero length for the next trial&amp;#10;            elif key in ['return']:&amp;#10;                print 'participant typed %s' %captured_string #show in debug window&amp;#10;                saveThisResponse(captured_string) #write to file&amp;#10;                captured_string = '' #reset to zero length &amp;#10;                subject_response_finished = 1 #allows the next trial to start&amp;#10;                &amp;#10;            #allow the participant to do deletions too , using the &amp;#10;            # delete key, and show the change they made&amp;#10;            elif key in ['delete','backspace']:&amp;#10;                captured_string = captured_string[:-1] #delete last character&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['up','down','left','right','lshift','rshift','tab','capslock','lctrl','lalt','rctrl','ralt', 'space', 'period', 'comma', 'apostrophe', 'slash', 'semicolon', 'bracketleft', 'bracketright', 'minus', 'grave', 'equal', 'tab', 'capslock', 'alt', 'control', 'backlash', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'z', 'x', 'c', 'v', 'b', 'n', 'm']:&amp;#10;                pass #do nothing when some keys are pressed&amp;#10;            #etc ...&amp;#10;&amp;#10;#if any other key is pressed, add it to the string and &amp;#10;            # show the participant what they typed&amp;#10;            else: &amp;#10;                captured_string = captured_string+key&amp;#10;                #show it&amp;#10;                updateTheResponse(captured_string)" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
    </Routine>
    <Routine name="block1">
      <CodeComponent name="code">
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="name" updates="None" val="code" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="#M1N06P&amp;#10;&amp;#10;trialClock = core.Clock()&amp;#10;from psychopy import visual,event,core&amp;#10;import time&amp;#10;import sys&amp;#10;import random&amp;#10;import csv&amp;#10;import math&amp;#10;from numpy import linspace&amp;#10;&amp;#10;win = visual.Window(size=(1366,768), fullscr = True, units = 'pix', monitor = 'testMonitor', color = [.4,.7,1],&amp;#10;    colorSpace = &quot;rgb&quot;)&amp;#10;&amp;#10;square = visual.Rect(win, lineWidth=0, fillColor=&quot;red&quot;, size=[.2,.2], pos=[-.35,0], units=&quot;height&quot;)&amp;#10;&amp;#10;numframes = 140&amp;#10;framesArray = linspace(0,(2 * math.pi),numframes)&amp;#10;count = 0&amp;#10;cycle = 0&amp;#10;left = 0&amp;#10;pauses = random.sample(range(1, 3), 1)&amp;#10;minimum = -.35&amp;#10;maximum = .35&amp;#10;while not cycle == 6:&amp;#10;    if count&gt;=(numframes):&amp;#10;        count = 0&amp;#10;        cycle += 2&amp;#10;        left += 1&amp;#10;    x=framesArray[count]&amp;#10;    if (minimum + .01*(int(count))) &lt; maximum:&amp;#10;        squarepos = minimum + .01*(int(count))&amp;#10;    else:&amp;#10;        squarepos = maximum - .01*((int(count))-70)&amp;#10;    square.setPos([squarepos, 0])&amp;#10;    square.draw()&amp;#10;    win.flip()&amp;#10;    if (squarepos == minimum and cycle == 0) or (squarepos == minimum and cycle == 6):&amp;#10;        time.sleep(.15)&amp;#10;    if squarepos == minimum and left == pauses[0]:&amp;#10;        time.sleep(.15)&amp;#10;    count += 1&amp;#10;&amp;#10;order+=1" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
      <CodeComponent name="code_2">
        <Param name="Begin Experiment" updates="constant" val="#setting up column headings&amp;#10;outfile = &quot;./Data/visualEVENTSpauses/%s_%s_Responses.tsv&quot; %(expInfo['participant'], expName)&amp;#10;f = open(outfile, 'a') #open our results file in append mode so we don't overwrite anything&amp;#10;f.write('subj \t')&amp;#10;f.write('order \t')&amp;#10;f.write('movement \t')&amp;#10;f.write('nummoves \t')&amp;#10;f.write('pauses \t')&amp;#10;f.write('numpauses \t')&amp;#10;f.write('PauseLocation \t')&amp;#10;f.write('happenQ \t')&amp;#10;f.write('numtimesQ')&amp;#10;f.write('\n')&amp;#10;f.close() #close and &quot;save&quot; the output file&amp;#10;&amp;#10;outfile = &quot;./Data/visualEVENTSpauses/Surveys/%s_%s_SurveyResponses.tsv&quot; %(expInfo['participant'], expName)&amp;#10;f = open(outfile, 'a') #open our results file in append mode so we don't overwrite anything&amp;#10;f.write('subj \t')&amp;#10;f.write('Question number \t')&amp;#10;f.write('Question \t')&amp;#10;f.write('Response')&amp;#10;f.write('\n')&amp;#10;f.close() #close and &quot;save&quot; the output file&amp;#10;&amp;#10;order=0" valType="extendedCode"/>
        <Param name="name" updates="None" val="code_2" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="#!/usr/bin/env python&amp;#10;&amp;#10;# SUPPLIED WITH NO GUARANTEES!!&amp;#10;from psychopy import locale_setup, gui, visual, core, data, event, logging, sound&amp;#10;#my lazy way of keeping time NB can be relatively inaccurate&amp;#10;import time &amp;#10;trialClock = core.Clock()&amp;#10;&amp;#10;# set up a stimulus window&amp;#10;win = visual.Window(size=(1366,768), fullscr=True,allowGUI=False,winType='pyglet',&amp;#10;            monitor='testMonitor', units ='deg', screen=0)&amp;#10;&amp;#10;#set up some fonts. If a list is provided, the first font found will be used.&amp;#10;sans = ['Gill Sans MT', 'Arial','Helvetica','Verdana']&amp;#10;&amp;#10;ResponseInstuction = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.5), text='What happened? Start typing and press return to continue.',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='white')&amp;#10;&amp;#10;#will be used to show the text they are typing: will update every &amp;#10;# time they type a letter&amp;#10;CapturedResponseString = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.07,&amp;#10;                        pos=(0, 0.0), text='',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='black')&amp;#10;&amp;#10;captured_string = '' #empty for now.. this is a string of zero length that &amp;#10;                                 # we will append our key presses to in sequence&amp;#10;&amp;#10;#a routine to save responses to file anytime we want to&amp;#10;def saveThisResponse(captured_string):&amp;#10;    outfile = &quot;./Data/visualEVENTSpauses/%s_%s_Responses.tsv&quot; %(expInfo['participant'], expName)&amp;#10;    f = open(outfile, 'a') #open our results file in append mode so we don't overwrite anything&amp;#10;    f.write('%s \t' %expInfo['participant'])&amp;#10;    f.write('%s' %order)&amp;#10;    f.write('\t')&amp;#10;    f.write('M1 \t')&amp;#10;    f.write('6 \t')&amp;#10;    f.write('1 \t')&amp;#10;    f.write('1 \t')&amp;#10;    f.write('%s' %pauses)&amp;#10;    f.write('\t')&amp;#10;    f.write(captured_string) #write the string they typed&amp;#10;    f.write('\t')&amp;#10;    f.close() #close and &quot;save&quot; the output file&amp;#10; &amp;#10;&amp;#10;#a routine to update the string on the screen as the participant types&amp;#10;def updateTheResponse(captured_string):&amp;#10;    CapturedResponseString.setText(captured_string)&amp;#10;    CapturedResponseString.draw()&amp;#10;    ResponseInstuction.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;#setup done, now start doing stuff&amp;#10;&amp;#10;# Create some handy timers&amp;#10;globalClock = core.Clock()  # to track the time since experiment started&amp;#10;routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine &amp;#10;&amp;#10;# ------Prepare to start Routine &quot;trial&quot;-------&amp;#10;t = 0&amp;#10;trialClock.reset()  # clock&amp;#10;frameN = -1&amp;#10;continueRoutine = True&amp;#10;# update component parameters for each repeat&amp;#10;&amp;#10;# keep track of which components have finished&amp;#10;trialComponents = []&amp;#10;for thisComponent in trialComponents:&amp;#10;    if hasattr(thisComponent, 'status'):&amp;#10;        thisComponent.status = NOT_STARTED&amp;#10;&amp;#10;# -------Start Routine &quot;trial&quot;-------&amp;#10;while continueRoutine:&amp;#10;    # get current time&amp;#10;    t = trialClock.getTime()&amp;#10;    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)&amp;#10;    # update/draw components on each frame&amp;#10;    &amp;#10;    &amp;#10;    # check if all components have finished&amp;#10;    if not continueRoutine:  # a component has requested a forced-end of Routine&amp;#10;        break&amp;#10;    continueRoutine = False  # will revert to True if at least one component still running&amp;#10;    for thisComponent in trialComponents:&amp;#10;        if hasattr(thisComponent, &quot;status&quot;) and thisComponent.status != FINISHED:&amp;#10;            continueRoutine = True&amp;#10;            break  # at least one component has not yet finished&amp;#10;&amp;#10;    # refresh the screen&amp;#10;    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen&amp;#10;        win.flip()&amp;#10;    #now instruct the participnat to respond&amp;#10;    ResponseInstuction.draw()  # draw instruction&amp;#10;    win.flip() # show instruction&amp;#10;    &amp;#10;    # now we will keep tracking what's happening on the keyboard&amp;#10;    # until the participant hits the return key&amp;#10;    subject_response_finished = 0 # only changes when they hit return&amp;#10;    &amp;#10;    #check for Esc key / return key presses each frame&amp;#10;    while subject_response_finished == 0:&amp;#10;        for key in event.getKeys():&amp;#10;            #quit at any point&amp;#10;            if key in ['escape']: &amp;#10;                win.close()&amp;#10;                core.quit()&amp;#10;                &amp;#10;            #if the participant hits return, save the string so far out &amp;#10;            #and reset the string to zero length for the next trial&amp;#10;            elif key in ['return']:&amp;#10;                print 'participant typed %s' %captured_string #show in debug window&amp;#10;                saveThisResponse(captured_string) #write to file&amp;#10;                captured_string = '' #reset to zero length &amp;#10;                subject_response_finished = 1 #allows the next trial to start&amp;#10;                &amp;#10;            #allow the participant to do deletions too , using the &amp;#10;            # delete key, and show the change they made&amp;#10;            elif key in ['delete','backspace']:&amp;#10;                captured_string = captured_string[:-1] #delete last character&amp;#10;                updateTheResponse(captured_string)&amp;#10;            #handle spaces&amp;#10;            elif key in ['space']:&amp;#10;                captured_string = captured_string+' '&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['period']:&amp;#10;                captured_string = captured_string+'.'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['comma']:&amp;#10;                captured_string = captured_string+','&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['apostrophe']:&amp;#10;                captured_string = captured_string+&quot;'&quot;&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['slash']:&amp;#10;                captured_string = captured_string+'/'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['semicolon']:&amp;#10;                captured_string = captured_string+';'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['bracketleft']:&amp;#10;                captured_string = captured_string+'['&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['bracketright']:&amp;#10;                captured_string = captured_string+']'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['minus']:&amp;#10;                captured_string = captured_string+'-'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['grave']:&amp;#10;                captured_string = captured_string+'`'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['equal']:&amp;#10;                captured_string = captured_string+'='&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['up','down','left','right','lshift','rshift','tab','capslock','lctrl','lalt','rctrl','ralt']:&amp;#10;                pass #do nothing when some keys are pressed&amp;#10;            #etc ...&amp;#10;&amp;#10;#if any other key is pressed, add it to the string and &amp;#10;            # show the participant what they typed&amp;#10;            else: &amp;#10;                captured_string = captured_string+key&amp;#10;                #show it&amp;#10;                updateTheResponse(captured_string)" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
      <CodeComponent name="code_6">
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="name" updates="None" val="code_6" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="#!/usr/bin/env python&amp;#10;&amp;#10;# SUPPLIED WITH NO GUARANTEES!!&amp;#10;from psychopy import visual, core, event&amp;#10;#my lazy way of keeping time NB can be relatively inaccurate&amp;#10;import time &amp;#10;&amp;#10;# set up a stimulus window&amp;#10;win = visual.Window(size=(1366,768), fullscr=True,allowGUI=False,winType='pyglet',&amp;#10;            monitor='testMonitor', units ='deg', screen=0)&amp;#10;&amp;#10;#set up some fonts. If a list is provided, the first font found will be used.&amp;#10;sans = ['Gill Sans MT', 'Arial','Helvetica','Verdana']&amp;#10;&amp;#10;ResponseInstuction = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.5), text='How many times? Please use the number keys at the top of the keyboard. Start typing and press return to continue.',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='white')&amp;#10;&amp;#10;#will be used to show the text they are typing: will update every &amp;#10;# time they type a letter&amp;#10;CapturedResponseString = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.0), text='',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='black')&amp;#10;&amp;#10;captured_string = '' #empty for now.. this is a string of zero length that &amp;#10;                                 # we will append our key presses to in sequence&amp;#10;&amp;#10;#a routine to save responses to file anytime we want to&amp;#10;def saveThisResponse(captured_string):&amp;#10;    outfile = &quot;./Data/visualEVENTSpauses/%s_%s_Responses.tsv&quot; %(expInfo['participant'], expName)&amp;#10;    f = open(outfile, 'a') #open our results file in append mode so we don't overwrite anything&amp;#10;    f.write(captured_string) #write the string they typed&amp;#10;    f.write('\n') # write a line ending&amp;#10;    f.close() #close and &quot;save&quot; the output file&amp;#10; &amp;#10;&amp;#10;#a routine to update the string on the screen as the participant types&amp;#10;def updateTheResponse(captured_string):&amp;#10;    CapturedResponseString.setText(captured_string)&amp;#10;    CapturedResponseString.draw()&amp;#10;    ResponseInstuction.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;#setup done, now start doing stuff&amp;#10;&amp;#10;# Create some handy timers&amp;#10;globalClock = core.Clock()  # to track the time since experiment started&amp;#10;routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine &amp;#10;&amp;#10;# ------Prepare to start Routine &quot;trial&quot;-------&amp;#10;t = 0&amp;#10;trialClock.reset()  # clock&amp;#10;frameN = -1&amp;#10;continueRoutine = True&amp;#10;# update component parameters for each repeat&amp;#10;&amp;#10;# keep track of which components have finished&amp;#10;trialComponents = []&amp;#10;for thisComponent in trialComponents:&amp;#10;    if hasattr(thisComponent, 'status'):&amp;#10;        thisComponent.status = NOT_STARTED&amp;#10;&amp;#10;# -------Start Routine &quot;trial&quot;-------&amp;#10;while continueRoutine:&amp;#10;    # get current time&amp;#10;    t = trialClock.getTime()&amp;#10;    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)&amp;#10;    # update/draw components on each frame&amp;#10;    &amp;#10;    &amp;#10;    # check if all components have finished&amp;#10;    if not continueRoutine:  # a component has requested a forced-end of Routine&amp;#10;        break&amp;#10;    continueRoutine = False  # will revert to True if at least one component still running&amp;#10;    for thisComponent in trialComponents:&amp;#10;        if hasattr(thisComponent, &quot;status&quot;) and thisComponent.status != FINISHED:&amp;#10;            continueRoutine = True&amp;#10;            break  # at least one component has not yet finished&amp;#10;&amp;#10;    # refresh the screen&amp;#10;    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen&amp;#10;        win.flip()&amp;#10;    #now instruct the participnat to respond&amp;#10;    ResponseInstuction.draw()  # draw instruction&amp;#10;    win.flip() # show instruction&amp;#10;    &amp;#10;    # now we will keep tracking what's happening on the keyboard&amp;#10;    # until the participant hits the return key&amp;#10;    subject_response_finished = 0 # only changes when they hit return&amp;#10;    &amp;#10;    #check for Esc key / return key presses each frame&amp;#10;    while subject_response_finished == 0:&amp;#10;        for key in event.getKeys():&amp;#10;            #quit at any point&amp;#10;            if key in ['escape']: &amp;#10;                win.close()&amp;#10;                core.quit()&amp;#10;                &amp;#10;            #if the participant hits return, save the string so far out &amp;#10;            #and reset the string to zero length for the next trial&amp;#10;            elif key in ['return']:&amp;#10;                print 'participant typed %s' %captured_string #show in debug window&amp;#10;                saveThisResponse(captured_string) #write to file&amp;#10;                captured_string = '' #reset to zero length &amp;#10;                subject_response_finished = 1 #allows the next trial to start&amp;#10;                &amp;#10;            #allow the participant to do deletions too , using the &amp;#10;            # delete key, and show the change they made&amp;#10;            elif key in ['delete','backspace']:&amp;#10;                captured_string = captured_string[:-1] #delete last character&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['up','down','left','right','lshift','rshift','tab','capslock','lctrl','lalt','rctrl','ralt', 'space', 'period', 'comma', 'apostrophe', 'slash', 'semicolon', 'bracketleft', 'bracketright', 'minus', 'grave', 'equal', 'tab', 'capslock', 'alt', 'control', 'backlash', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'z', 'x', 'c', 'v', 'b', 'n', 'm']:&amp;#10;                pass #do nothing when some keys are pressed&amp;#10;            #etc ...&amp;#10;&amp;#10;#if any other key is pressed, add it to the string and &amp;#10;            # show the participant what they typed&amp;#10;            else: &amp;#10;                captured_string = captured_string+key&amp;#10;                #show it&amp;#10;                updateTheResponse(captured_string)" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
    </Routine>
    <Routine name="instr">
      <TextComponent name="text">
        <Param name="opacity" updates="constant" val="1" valType="code"/>
        <Param name="colorSpace" updates="constant" val="rgb" valType="str"/>
        <Param name="name" updates="None" val="text" valType="code"/>
        <Param name="wrapWidth" updates="constant" val="" valType="code"/>
        <Param name="color" updates="constant" val="white" valType="str"/>
        <Param name="text" updates="constant" val="You will be shown a series of very simple animations. &amp;#10;Following each animation, you will be asked to answer two questions.&amp;#10;&amp;#10;The first question will be, simply: what happened in that animation?  You will be given space to type out your description.&amp;#10;&amp;#10;The second question will be, simply: &quot;how many times did it happen?&quot; You might think that this is a tricky question, but we're just interested in your first intuitions about numbers of events. Here you will enter a number using the keys at the top of the keyboard.&amp;#10; &amp;#10;As you move through the animations, you may notice that there are some differences between the animations. We ask that you not reference differences between the animations when describing a single animation.&amp;#10;&amp;#10;Please tell the experimenter if you have any questions. When the experimenter has left the room, press &quot;return&quot; to begin. " valType="str"/>
        <Param name="stopVal" updates="constant" val="" valType="code"/>
        <Param name="durationEstim" updates="None" val="" valType="code"/>
        <Param name="pos" updates="constant" val="(0, 0)" valType="code"/>
        <Param name="flip" updates="constant" val="" valType="str"/>
        <Param name="startEstim" updates="None" val="" valType="code"/>
        <Param name="units" updates="None" val="from exp settings" valType="str"/>
        <Param name="startType" updates="None" val="time (s)" valType="str"/>
        <Param name="ori" updates="constant" val="0" valType="code"/>
        <Param name="stopType" updates="None" val="condition" valType="str"/>
        <Param name="startVal" updates="None" val="0.0" valType="code"/>
        <Param name="font" updates="constant" val="Arial" valType="str"/>
        <Param name="letterHeight" updates="constant" val="0.07" valType="code"/>
      </TextComponent>
      <KeyboardComponent name="key_resp_2">
        <Param name="correctAns" updates="constant" val="" valType="str"/>
        <Param name="storeCorrect" updates="constant" val="False" valType="bool"/>
        <Param name="name" updates="None" val="key_resp_2" valType="code"/>
        <Param name="stopVal" updates="constant" val="" valType="code"/>
        <Param name="durationEstim" updates="None" val="" valType="code"/>
        <Param name="forceEndRoutine" updates="constant" val="True" valType="bool"/>
        <Param name="startEstim" updates="None" val="" valType="code"/>
        <Param name="discard previous" updates="constant" val="True" valType="bool"/>
        <Param name="startType" updates="None" val="time (s)" valType="str"/>
        <Param name="allowedKeys" updates="constant" val="'return'" valType="code"/>
        <Param name="stopType" updates="None" val="duration (s)" valType="str"/>
        <Param name="startVal" updates="None" val="0.0" valType="code"/>
        <Param name="store" updates="constant" val="nothing" valType="str"/>
        <Param name="syncScreenRefresh" updates="constant" val="True" valType="bool"/>
      </KeyboardComponent>
    </Routine>
    <Routine name="blockSelect">
      <CodeComponent name="code_3">
        <Param name="Begin Experiment" updates="constant" val="nRepsblock1=0&amp;#10;nRepsblock2=0&amp;#10;nRepsblock3=0&amp;#10;nRepsblock4=0&amp;#10;nRepsblock5=0&amp;#10;nRepsblock6=0&amp;#10;nRepsblock7=0&amp;#10;nRepsblock8=0&amp;#10;nRepsblock9=0&amp;#10;&amp;#10;#free response code from:https://groups.google.com/forum/#!topic/psychopy-users/oyQZFv3ZM_M&amp;#10;#randomization code from:https://computingforpsychologists.wordpress.com/2013/11/12/how-to-hack-conditional-branching-in-the-psychopy-builder/" valType="extendedCode"/>
        <Param name="name" updates="None" val="code_3" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="win = visual.Window(&amp;#10;    size=(1366, 768), fullscr=True, screen=0,&amp;#10;    allowGUI=False, allowStencil=False,&amp;#10;    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',&amp;#10;    blendMode='avg', useFBO=True)&amp;#10;# store frame rate of monitor if we can measure it&amp;#10;expInfo['frameRate'] = win.getActualFrameRate()&amp;#10;if expInfo['frameRate'] != None:&amp;#10;    frameDur = 1.0 / round(expInfo['frameRate'])&amp;#10;else:&amp;#10;    frameDur = 1.0 / 60.0  # could not measure, so guess&amp;#10;&amp;#10;# Initialize components for Routine &quot;trial&quot; (fixation crosses)&amp;#10;trialClock = core.Clock()&amp;#10;text = visual.TextStim(win=win, name='text',&amp;#10;    text=u'+',&amp;#10;    font=u'Arial',&amp;#10;    pos=(0, 0), height=0.1, wrapWidth=None, ori=0, &amp;#10;    color=u'white', colorSpace='rgb', opacity=1,&amp;#10;    depth=0.0);&amp;#10;&amp;#10;# Create some handy timers&amp;#10;globalClock = core.Clock()  # to track the time since experiment started&amp;#10;routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine &amp;#10;&amp;#10;# ------Prepare to start Routine &quot;trial&quot;-------&amp;#10;t = 0&amp;#10;trialClock.reset()  # clock&amp;#10;frameN = -1&amp;#10;continueRoutine = True&amp;#10;routineTimer.add(1.000000)&amp;#10;# update component parameters for each repeat&amp;#10;# keep track of which components have finished&amp;#10;trialComponents = [text]&amp;#10;for thisComponent in trialComponents:&amp;#10;    if hasattr(thisComponent, 'status'):&amp;#10;        thisComponent.status = NOT_STARTED&amp;#10;&amp;#10;# -------Start Routine &quot;trial&quot;-------&amp;#10;while continueRoutine and routineTimer.getTime() &gt; 0:&amp;#10;    # get current time&amp;#10;    t = trialClock.getTime()&amp;#10;    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)&amp;#10;    # update/draw components on each frame&amp;#10;    &amp;#10;    # *text* updates&amp;#10;    if t &gt;= 0.0 and text.status == NOT_STARTED:&amp;#10;        # keep track of start time/frame for later&amp;#10;        text.tStart = t&amp;#10;        text.frameNStart = frameN  # exact frame index&amp;#10;        text.setAutoDraw(True)&amp;#10;    frameRemains = 0.0 + 1.0- win.monitorFramePeriod * 0.75  # most of one frame period left&amp;#10;    if text.status == STARTED and t &gt;= frameRemains:&amp;#10;        text.setAutoDraw(False)&amp;#10;    &amp;#10;    # check if all components have finished&amp;#10;    if not continueRoutine:  # a component has requested a forced-end of Routine&amp;#10;        break&amp;#10;    continueRoutine = False  # will revert to True if at least one component still running&amp;#10;    for thisComponent in trialComponents:&amp;#10;        if hasattr(thisComponent, &quot;status&quot;) and thisComponent.status != FINISHED:&amp;#10;            continueRoutine = True&amp;#10;            break  # at least one component has not yet finished&amp;#10;    &amp;#10;    # check for quit (the Esc key)&amp;#10;    if endExpNow or event.getKeys(keyList=[&quot;escape&quot;]):&amp;#10;        core.quit()&amp;#10;    &amp;#10;    # refresh the screen&amp;#10;    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen&amp;#10;        win.flip()&amp;#10;&amp;#10;&amp;#10;if selectBlock==1:&amp;#10; nRepsblock1=1&amp;#10; nRepsblock2=0&amp;#10; nRepsblock3=0&amp;#10; nRepsblock4=0&amp;#10; nRepsblock5=0&amp;#10; nRepsblock6=0&amp;#10; nRepsblock7=0&amp;#10; nRepsblock8=0&amp;#10; nRepsblock9=0&amp;#10;elif selectBlock==2:&amp;#10; nRepsblock1=0&amp;#10; nRepsblock2=1&amp;#10; nRepsblock3=0&amp;#10; nRepsblock4=0&amp;#10; nRepsblock5=0&amp;#10; nRepsblock6=0&amp;#10; nRepsblock7=0&amp;#10; nRepsblock8=0&amp;#10; nRepsblock9=0&amp;#10;elif selectBlock==3:&amp;#10; nRepsblock1=0&amp;#10; nRepsblock2=0&amp;#10; nRepsblock3=1&amp;#10; nRepsblock4=0&amp;#10; nRepsblock5=0&amp;#10; nRepsblock6=0&amp;#10; nRepsblock7=0&amp;#10; nRepsblock8=0&amp;#10; nRepsblock9=0&amp;#10;elif selectBlock==4:&amp;#10; nRepsblock1=0&amp;#10; nRepsblock2=0&amp;#10; nRepsblock3=0&amp;#10; nRepsblock4=1&amp;#10; nRepsblock5=0&amp;#10; nRepsblock6=0&amp;#10; nRepsblock7=0&amp;#10; nRepsblock8=0&amp;#10; nRepsblock9=0&amp;#10;elif selectBlock==5:&amp;#10; nRepsblock1=0&amp;#10; nRepsblock2=0&amp;#10; nRepsblock3=0&amp;#10; nRepsblock4=0&amp;#10; nRepsblock5=1&amp;#10; nRepsblock6=0&amp;#10; nRepsblock7=0&amp;#10; nRepsblock8=0&amp;#10; nRepsblock9=0&amp;#10;elif selectBlock==6:&amp;#10; nRepsblock1=0&amp;#10; nRepsblock2=0&amp;#10; nRepsblock3=0&amp;#10; nRepsblock4=0&amp;#10; nRepsblock5=0&amp;#10; nRepsblock6=1&amp;#10; nRepsblock7=0&amp;#10; nRepsblock8=0&amp;#10; nRepsblock9=0&amp;#10;elif selectBlock==7:&amp;#10; nRepsblock1=0&amp;#10; nRepsblock2=0&amp;#10; nRepsblock3=0&amp;#10; nRepsblock4=0&amp;#10; nRepsblock5=0&amp;#10; nRepsblock6=0&amp;#10; nRepsblock7=1&amp;#10; nRepsblock8=0&amp;#10; nRepsblock9=0&amp;#10;elif selectBlock==8:&amp;#10; nRepsblock1=0&amp;#10; nRepsblock2=0&amp;#10; nRepsblock3=0&amp;#10; nRepsblock4=0&amp;#10; nRepsblock5=0&amp;#10; nRepsblock6=0&amp;#10; nRepsblock7=0&amp;#10; nRepsblock8=1&amp;#10; nRepsblock9=0&amp;#10;elif selectBlock==9:&amp;#10; nRepsblock1=0&amp;#10; nRepsblock2=0&amp;#10; nRepsblock3=0&amp;#10; nRepsblock4=0&amp;#10; nRepsblock5=0&amp;#10; nRepsblock6=0&amp;#10; nRepsblock7=0&amp;#10; nRepsblock8=0&amp;#10; nRepsblock9=1" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="#endscreen&amp;#10;#i used the same code from the free response boxes, but got rid of all key responses except enter&amp;#10;#!/usr/bin/env python&amp;#10;&amp;#10;# SUPPLIED WITH NO GUARANTEES!!&amp;#10;from psychopy import visual, core, event&amp;#10;#my lazy way of keeping time NB can be relatively inaccurate&amp;#10;import time &amp;#10;trialClock = core.Clock()&amp;#10;&amp;#10;# set up a stimulus window&amp;#10;win = visual.Window(size=(1366,768), fullscr=True,allowGUI=False,winType='pyglet',&amp;#10;            monitor='testMonitor', units ='deg', screen=0)&amp;#10;&amp;#10;#set up some fonts. If a list is provided, the first font found will be used.&amp;#10;sans = ['Gill Sans MT', 'Arial','Helvetica','Verdana']&amp;#10;&amp;#10;ResponseInstuction = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0), text='Thank you for your participation!\n\nPress return to take an optional survey.',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='white')&amp;#10;&amp;#10;#will be used to show the text they are typing: will update every &amp;#10;# time they type a letter&amp;#10;#nothing will actually show up for this one, participant just presses enter to advance&amp;#10;CapturedResponseString = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.0), text='',&amp;#10;                        font=sans, &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='white')&amp;#10;&amp;#10;captured_string = '' #empty for now.. this is a string of zero length that &amp;#10;                                 # we will append our key presses to in sequence&amp;#10; &amp;#10;&amp;#10;#a routine to update the string on the screen as the participant types&amp;#10;def updateTheResponse(captured_string):&amp;#10;    CapturedResponseString.setText(captured_string)&amp;#10;    CapturedResponseString.draw()&amp;#10;    ResponseInstuction.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;#setup done, now start doing stuff&amp;#10;&amp;#10;# Create some handy timers&amp;#10;globalClock = core.Clock()  # to track the time since experiment started&amp;#10;routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine &amp;#10;&amp;#10;# ------Prepare to start Routine &quot;trial&quot;-------&amp;#10;t = 0&amp;#10;trialClock.reset()  # clock&amp;#10;frameN = -1&amp;#10;continueRoutine = True&amp;#10;# update component parameters for each repeat&amp;#10;&amp;#10;# keep track of which components have finished&amp;#10;trialComponents = []&amp;#10;for thisComponent in trialComponents:&amp;#10;    if hasattr(thisComponent, 'status'):&amp;#10;        thisComponent.status = NOT_STARTED&amp;#10;&amp;#10;# -------Start Routine &quot;trial&quot;-------&amp;#10;while continueRoutine:&amp;#10;    # get current time&amp;#10;    t = trialClock.getTime()&amp;#10;    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)&amp;#10;    # update/draw components on each frame&amp;#10;    &amp;#10;    &amp;#10;    # check if all components have finished&amp;#10;    if not continueRoutine:  # a component has requested a forced-end of Routine&amp;#10;        break&amp;#10;    continueRoutine = False  # will revert to True if at least one component still running&amp;#10;    for thisComponent in trialComponents:&amp;#10;        if hasattr(thisComponent, &quot;status&quot;) and thisComponent.status != FINISHED:&amp;#10;            continueRoutine = True&amp;#10;            break  # at least one component has not yet finished&amp;#10;&amp;#10;    # refresh the screen&amp;#10;    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen&amp;#10;        win.flip()&amp;#10;    #now instruct the participnat to respond&amp;#10;    ResponseInstuction.draw()  # draw instruction&amp;#10;    win.flip() # show instruction&amp;#10;    &amp;#10;    # now we will keep tracking what's happening on the keyboard&amp;#10;    # until the participant hits the return key&amp;#10;    subject_response_finished = 0 # only changes when they hit return&amp;#10;    &amp;#10;    #check for Esc key / return key presses each frame&amp;#10;    while subject_response_finished == 0:&amp;#10;        for key in event.getKeys():&amp;#10;            #quit at any point&amp;#10;            if key in ['escape']: &amp;#10;                win.close()&amp;#10;                core.quit()&amp;#10;                &amp;#10;            #if the participant hits return, save the string so far out &amp;#10;            #and reset the string to zero length for the next trial&amp;#10;            elif key in ['return']:&amp;#10;                print 'participant typed %s' %captured_string #show in debug window&amp;#10;                saveThisResponse(captured_string) #write to file&amp;#10;                captured_string = '' #reset to zero length &amp;#10;                subject_response_finished = 1 #allows the next trial to start&amp;#10;&amp;#10;#survey question 1&amp;#10;#!/usr/bin/env python&amp;#10;&amp;#10;# SUPPLIED WITH NO GUARANTEES!!&amp;#10;from psychopy import visual, core, event&amp;#10;#my lazy way of keeping time NB can be relatively inaccurate&amp;#10;import time &amp;#10;trialClock = core.Clock()&amp;#10;&amp;#10;# set up a stimulus window&amp;#10;win = visual.Window(size=(1366,768), fullscr=True,allowGUI=False,winType='pyglet',&amp;#10;            monitor='testMonitor', units ='deg', screen=0)&amp;#10;&amp;#10;#set up some fonts. If a list is provided, the first font found will be used.&amp;#10;sans = ['Gill Sans MT', 'Arial','Helvetica','Verdana']&amp;#10;&amp;#10;ResponseInstuction = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.5), text='What factors do you think influenced your answers to the &quot;how many times&quot; question? Start typing and press return to continue.',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='white')&amp;#10;&amp;#10;#will be used to show the text they are typing: will update every &amp;#10;# time they type a letter&amp;#10;CapturedResponseString = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.07,&amp;#10;                        pos=(0, 0.0), text='',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='black')&amp;#10;&amp;#10;captured_string = '' #empty for now.. this is a string of zero length that &amp;#10;                                 # we will append our key presses to in sequence&amp;#10;&amp;#10;#a routine to save responses to file anytime we want to&amp;#10;def saveThisResponse(captured_string):&amp;#10;    outfile = &quot;./Data/visualEVENTSpauses/Surveys/%s_%s_SurveyResponses.tsv&quot; %(expInfo['participant'], expName)&amp;#10;    f = open(outfile, 'a') #open our results file in append mode so we don't overwrite anything&amp;#10;    f.write('%s \t' %expInfo['participant'])&amp;#10;    f.write('Question 1 \t')&amp;#10;    f.write('What factors do you think influenced your answers to the &quot;how many times&quot; question? \t')&amp;#10;    f.write(captured_string) #write the string they typed&amp;#10;    f.write('\t')&amp;#10;    f.write('\n')&amp;#10;    f.close() #close and &quot;save&quot; the output file&amp;#10; &amp;#10;&amp;#10;#a routine to update the string on the screen as the participant types&amp;#10;def updateTheResponse(captured_string):&amp;#10;    CapturedResponseString.setText(captured_string)&amp;#10;    CapturedResponseString.draw()&amp;#10;    ResponseInstuction.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;#setup done, now start doing stuff&amp;#10;&amp;#10;# Create some handy timers&amp;#10;globalClock = core.Clock()  # to track the time since experiment started&amp;#10;routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine &amp;#10;&amp;#10;# ------Prepare to start Routine &quot;trial&quot;-------&amp;#10;t = 0&amp;#10;trialClock.reset()  # clock&amp;#10;frameN = -1&amp;#10;continueRoutine = True&amp;#10;# update component parameters for each repeat&amp;#10;&amp;#10;# keep track of which components have finished&amp;#10;trialComponents = []&amp;#10;for thisComponent in trialComponents:&amp;#10;    if hasattr(thisComponent, 'status'):&amp;#10;        thisComponent.status = NOT_STARTED&amp;#10;&amp;#10;# -------Start Routine &quot;trial&quot;-------&amp;#10;while continueRoutine:&amp;#10;    # get current time&amp;#10;    t = trialClock.getTime()&amp;#10;    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)&amp;#10;    # update/draw components on each frame&amp;#10;    &amp;#10;    &amp;#10;    # check if all components have finished&amp;#10;    if not continueRoutine:  # a component has requested a forced-end of Routine&amp;#10;        break&amp;#10;    continueRoutine = False  # will revert to True if at least one component still running&amp;#10;    for thisComponent in trialComponents:&amp;#10;        if hasattr(thisComponent, &quot;status&quot;) and thisComponent.status != FINISHED:&amp;#10;            continueRoutine = True&amp;#10;            break  # at least one component has not yet finished&amp;#10;&amp;#10;    # refresh the screen&amp;#10;    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen&amp;#10;        win.flip()&amp;#10;    #now instruct the participnat to respond&amp;#10;    ResponseInstuction.draw()  # draw instruction&amp;#10;    win.flip() # show instruction&amp;#10;    &amp;#10;    # now we will keep tracking what's happening on the keyboard&amp;#10;    # until the participant hits the return key&amp;#10;    subject_response_finished = 0 # only changes when they hit return&amp;#10;    &amp;#10;    #check for Esc key / return key presses each frame&amp;#10;    while subject_response_finished == 0:&amp;#10;        for key in event.getKeys():&amp;#10;            #quit at any point&amp;#10;            if key in ['escape']: &amp;#10;                win.close()&amp;#10;                core.quit()&amp;#10;                &amp;#10;            #if the participant hits return, save the string so far out &amp;#10;            #and reset the string to zero length for the next trial&amp;#10;            elif key in ['return']:&amp;#10;                print 'participant typed %s' %captured_string #show in debug window&amp;#10;                saveThisResponse(captured_string) #write to file&amp;#10;                captured_string = '' #reset to zero length &amp;#10;                subject_response_finished = 1 #allows the next trial to start&amp;#10;                &amp;#10;            #allow the participant to do deletions too , using the &amp;#10;            # delete key, and show the change they made&amp;#10;            elif key in ['delete','backspace']:&amp;#10;                captured_string = captured_string[:-1] #delete last character&amp;#10;                updateTheResponse(captured_string)&amp;#10;            #handle spaces&amp;#10;            elif key in ['space']:&amp;#10;                captured_string = captured_string+' '&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['period']:&amp;#10;                captured_string = captured_string+'.'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['comma']:&amp;#10;                captured_string = captured_string+','&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['apostrophe']:&amp;#10;                captured_string = captured_string+&quot;'&quot;&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['slash']:&amp;#10;                captured_string = captured_string+'/'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['semicolon']:&amp;#10;                captured_string = captured_string+';'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['bracketleft']:&amp;#10;                captured_string = captured_string+'['&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['bracketright']:&amp;#10;                captured_string = captured_string+']'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['minus']:&amp;#10;                captured_string = captured_string+'-'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['grave']:&amp;#10;                captured_string = captured_string+'`'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['equal']:&amp;#10;                captured_string = captured_string+'='&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['up','down','left','right','lshift','rshift','tab','capslock','lctrl','lalt','rctrl','ralt']:&amp;#10;                pass #do nothing when some keys are pressed&amp;#10;            #etc ...&amp;#10;&amp;#10;#if any other key is pressed, add it to the string and &amp;#10;            # show the participant what they typed&amp;#10;            else: &amp;#10;                captured_string = captured_string+key&amp;#10;                #show it&amp;#10;                updateTheResponse(captured_string)&amp;#10;&amp;#10;#survey question 2&amp;#10;#!/usr/bin/env python&amp;#10;&amp;#10;# SUPPLIED WITH NO GUARANTEES!!&amp;#10;from psychopy import visual, core, event&amp;#10;#my lazy way of keeping time NB can be relatively inaccurate&amp;#10;import time &amp;#10;trialClock = core.Clock()&amp;#10;&amp;#10;# set up a stimulus window&amp;#10;win = visual.Window(size=(1366,768), fullscr=True,allowGUI=False,winType='pyglet',&amp;#10;            monitor='testMonitor', units ='deg', screen=0)&amp;#10;&amp;#10;#set up some fonts. If a list is provided, the first font found will be used.&amp;#10;sans = ['Gill Sans MT', 'Arial','Helvetica','Verdana']&amp;#10;&amp;#10;ResponseInstuction = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.5), text='What differences, if any, did you notice between the animations? Start typing and press return to continue.',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='white')&amp;#10;&amp;#10;#will be used to show the text they are typing: will update every &amp;#10;# time they type a letter&amp;#10;CapturedResponseString = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.07,&amp;#10;                        pos=(0, 0.0), text='',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='black')&amp;#10;&amp;#10;captured_string = '' #empty for now.. this is a string of zero length that &amp;#10;                                 # we will append our key presses to in sequence&amp;#10;&amp;#10;#a routine to save responses to file anytime we want to&amp;#10;def saveThisResponse(captured_string):&amp;#10;    outfile = &quot;./Data/visualEVENTSpauses/Surveys/%s_%s_SurveyResponses.tsv&quot; %(expInfo['participant'], expName)&amp;#10;    f = open(outfile, 'a') #open our results file in append mode so we don't overwrite anything&amp;#10;    f.write('%s \t' %expInfo['participant'])&amp;#10;    f.write('Question 2 \t')&amp;#10;    f.write('What differences, if any, did you notice between the animations? \t')&amp;#10;    f.write(captured_string) #write the string they typed&amp;#10;    f.write('\t')&amp;#10;    f.write('\n')&amp;#10;    f.close() #close and &quot;save&quot; the output file&amp;#10; &amp;#10;&amp;#10;#a routine to update the string on the screen as the participant types&amp;#10;def updateTheResponse(captured_string):&amp;#10;    CapturedResponseString.setText(captured_string)&amp;#10;    CapturedResponseString.draw()&amp;#10;    ResponseInstuction.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;#setup done, now start doing stuff&amp;#10;&amp;#10;# Create some handy timers&amp;#10;globalClock = core.Clock()  # to track the time since experiment started&amp;#10;routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine &amp;#10;&amp;#10;# ------Prepare to start Routine &quot;trial&quot;-------&amp;#10;t = 0&amp;#10;trialClock.reset()  # clock&amp;#10;frameN = -1&amp;#10;continueRoutine = True&amp;#10;# update component parameters for each repeat&amp;#10;&amp;#10;# keep track of which components have finished&amp;#10;trialComponents = []&amp;#10;for thisComponent in trialComponents:&amp;#10;    if hasattr(thisComponent, 'status'):&amp;#10;        thisComponent.status = NOT_STARTED&amp;#10;&amp;#10;# -------Start Routine &quot;trial&quot;-------&amp;#10;while continueRoutine:&amp;#10;    # get current time&amp;#10;    t = trialClock.getTime()&amp;#10;    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)&amp;#10;    # update/draw components on each frame&amp;#10;    &amp;#10;    &amp;#10;    # check if all components have finished&amp;#10;    if not continueRoutine:  # a component has requested a forced-end of Routine&amp;#10;        break&amp;#10;    continueRoutine = False  # will revert to True if at least one component still running&amp;#10;    for thisComponent in trialComponents:&amp;#10;        if hasattr(thisComponent, &quot;status&quot;) and thisComponent.status != FINISHED:&amp;#10;            continueRoutine = True&amp;#10;            break  # at least one component has not yet finished&amp;#10;&amp;#10;    # refresh the screen&amp;#10;    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen&amp;#10;        win.flip()&amp;#10;    #now instruct the participnat to respond&amp;#10;    ResponseInstuction.draw()  # draw instruction&amp;#10;    win.flip() # show instruction&amp;#10;    &amp;#10;    # now we will keep tracking what's happening on the keyboard&amp;#10;    # until the participant hits the return key&amp;#10;    subject_response_finished = 0 # only changes when they hit return&amp;#10;    &amp;#10;    #check for Esc key / return key presses each frame&amp;#10;    while subject_response_finished == 0:&amp;#10;        for key in event.getKeys():&amp;#10;            #quit at any point&amp;#10;            if key in ['escape']: &amp;#10;                win.close()&amp;#10;                core.quit()&amp;#10;                &amp;#10;            #if the participant hits return, save the string so far out &amp;#10;            #and reset the string to zero length for the next trial&amp;#10;            elif key in ['return']:&amp;#10;                print 'participant typed %s' %captured_string #show in debug window&amp;#10;                saveThisResponse(captured_string) #write to file&amp;#10;                captured_string = '' #reset to zero length &amp;#10;                subject_response_finished = 1 #allows the next trial to start&amp;#10;                &amp;#10;            #allow the participant to do deletions too , using the &amp;#10;            # delete key, and show the change they made&amp;#10;            elif key in ['delete','backspace']:&amp;#10;                captured_string = captured_string[:-1] #delete last character&amp;#10;                updateTheResponse(captured_string)&amp;#10;            #handle spaces&amp;#10;            elif key in ['space']:&amp;#10;                captured_string = captured_string+' '&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['period']:&amp;#10;                captured_string = captured_string+'.'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['comma']:&amp;#10;                captured_string = captured_string+','&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['apostrophe']:&amp;#10;                captured_string = captured_string+&quot;'&quot;&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['slash']:&amp;#10;                captured_string = captured_string+'/'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['semicolon']:&amp;#10;                captured_string = captured_string+';'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['bracketleft']:&amp;#10;                captured_string = captured_string+'['&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['bracketright']:&amp;#10;                captured_string = captured_string+']'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['minus']:&amp;#10;                captured_string = captured_string+'-'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['grave']:&amp;#10;                captured_string = captured_string+'`'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['equal']:&amp;#10;                captured_string = captured_string+'='&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['up','down','left','right','lshift','rshift','tab','capslock','lctrl','lalt','rctrl','ralt']:&amp;#10;                pass #do nothing when some keys are pressed&amp;#10;            #etc ...&amp;#10;&amp;#10;#if any other key is pressed, add it to the string and &amp;#10;            # show the participant what they typed&amp;#10;            else: &amp;#10;                captured_string = captured_string+key&amp;#10;                #show it&amp;#10;                updateTheResponse(captured_string)&amp;#10;&amp;#10;#survey question 3&amp;#10;#!/usr/bin/env python&amp;#10;&amp;#10;# SUPPLIED WITH NO GUARANTEES!!&amp;#10;from psychopy import visual, core, event&amp;#10;#my lazy way of keeping time NB can be relatively inaccurate&amp;#10;import time &amp;#10;trialClock = core.Clock()&amp;#10;&amp;#10;# set up a stimulus window&amp;#10;win = visual.Window(size=(1366,768), fullscr=True,allowGUI=False,winType='pyglet',&amp;#10;            monitor='testMonitor', units ='deg', screen=0)&amp;#10;&amp;#10;#set up some fonts. If a list is provided, the first font found will be used.&amp;#10;sans = ['Gill Sans MT', 'Arial','Helvetica','Verdana']&amp;#10;&amp;#10;ResponseInstuction = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.5), text='Did you find this task challenging? Why or why not? Start typing and press return to continue.',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='white')&amp;#10;&amp;#10;#will be used to show the text they are typing: will update every &amp;#10;# time they type a letter&amp;#10;CapturedResponseString = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.07,&amp;#10;                        pos=(0, 0.0), text='',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='black')&amp;#10;&amp;#10;captured_string = '' #empty for now.. this is a string of zero length that &amp;#10;                                 # we will append our key presses to in sequence&amp;#10;&amp;#10;#a routine to save responses to file anytime we want to&amp;#10;def saveThisResponse(captured_string):&amp;#10;    outfile = &quot;./Data/visualEVENTSpauses/Surveys/%s_%s_SurveyResponses.tsv&quot; %(expInfo['participant'], expName)&amp;#10;    f = open(outfile, 'a') #open our results file in append mode so we don't overwrite anything&amp;#10;    f.write('%s \t' %expInfo['participant'])&amp;#10;    f.write('Question 3 \t')&amp;#10;    f.write('Did you find this task challenging? Why or why not? \t')&amp;#10;    f.write(captured_string) #write the string they typed&amp;#10;    f.write('\t')&amp;#10;    f.write('\n')&amp;#10;    f.close() #close and &quot;save&quot; the output file&amp;#10; &amp;#10;&amp;#10;#a routine to update the string on the screen as the participant types&amp;#10;def updateTheResponse(captured_string):&amp;#10;    CapturedResponseString.setText(captured_string)&amp;#10;    CapturedResponseString.draw()&amp;#10;    ResponseInstuction.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;#setup done, now start doing stuff&amp;#10;&amp;#10;# Create some handy timers&amp;#10;globalClock = core.Clock()  # to track the time since experiment started&amp;#10;routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine &amp;#10;&amp;#10;# ------Prepare to start Routine &quot;trial&quot;-------&amp;#10;t = 0&amp;#10;trialClock.reset()  # clock&amp;#10;frameN = -1&amp;#10;continueRoutine = True&amp;#10;# update component parameters for each repeat&amp;#10;&amp;#10;# keep track of which components have finished&amp;#10;trialComponents = []&amp;#10;for thisComponent in trialComponents:&amp;#10;    if hasattr(thisComponent, 'status'):&amp;#10;        thisComponent.status = NOT_STARTED&amp;#10;&amp;#10;# -------Start Routine &quot;trial&quot;-------&amp;#10;while continueRoutine:&amp;#10;    # get current time&amp;#10;    t = trialClock.getTime()&amp;#10;    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)&amp;#10;    # update/draw components on each frame&amp;#10;    &amp;#10;    &amp;#10;    # check if all components have finished&amp;#10;    if not continueRoutine:  # a component has requested a forced-end of Routine&amp;#10;        break&amp;#10;    continueRoutine = False  # will revert to True if at least one component still running&amp;#10;    for thisComponent in trialComponents:&amp;#10;        if hasattr(thisComponent, &quot;status&quot;) and thisComponent.status != FINISHED:&amp;#10;            continueRoutine = True&amp;#10;            break  # at least one component has not yet finished&amp;#10;&amp;#10;    # refresh the screen&amp;#10;    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen&amp;#10;        win.flip()&amp;#10;    #now instruct the participnat to respond&amp;#10;    ResponseInstuction.draw()  # draw instruction&amp;#10;    win.flip() # show instruction&amp;#10;    &amp;#10;    # now we will keep tracking what's happening on the keyboard&amp;#10;    # until the participant hits the return key&amp;#10;    subject_response_finished = 0 # only changes when they hit return&amp;#10;    &amp;#10;    #check for Esc key / return key presses each frame&amp;#10;    while subject_response_finished == 0:&amp;#10;        for key in event.getKeys():&amp;#10;            #quit at any point&amp;#10;            if key in ['escape']: &amp;#10;                win.close()&amp;#10;                core.quit()&amp;#10;                &amp;#10;            #if the participant hits return, save the string so far out &amp;#10;            #and reset the string to zero length for the next trial&amp;#10;            elif key in ['return']:&amp;#10;                print 'participant typed %s' %captured_string #show in debug window&amp;#10;                saveThisResponse(captured_string) #write to file&amp;#10;                captured_string = '' #reset to zero length &amp;#10;                subject_response_finished = 1 #allows the next trial to start&amp;#10;                &amp;#10;            #allow the participant to do deletions too , using the &amp;#10;            # delete key, and show the change they made&amp;#10;            elif key in ['delete','backspace']:&amp;#10;                captured_string = captured_string[:-1] #delete last character&amp;#10;                updateTheResponse(captured_string)&amp;#10;            #handle spaces&amp;#10;            elif key in ['space']:&amp;#10;                captured_string = captured_string+' '&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['period']:&amp;#10;                captured_string = captured_string+'.'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['comma']:&amp;#10;                captured_string = captured_string+','&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['apostrophe']:&amp;#10;                captured_string = captured_string+&quot;'&quot;&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['slash']:&amp;#10;                captured_string = captured_string+'/'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['semicolon']:&amp;#10;                captured_string = captured_string+';'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['bracketleft']:&amp;#10;                captured_string = captured_string+'['&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['bracketright']:&amp;#10;                captured_string = captured_string+']'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['minus']:&amp;#10;                captured_string = captured_string+'-'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['grave']:&amp;#10;                captured_string = captured_string+'`'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['equal']:&amp;#10;                captured_string = captured_string+'='&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['up','down','left','right','lshift','rshift','tab','capslock','lctrl','lalt','rctrl','ralt']:&amp;#10;                pass #do nothing when some keys are pressed&amp;#10;            #etc ...&amp;#10;&amp;#10;#if any other key is pressed, add it to the string and &amp;#10;            # show the participant what they typed&amp;#10;            else: &amp;#10;                captured_string = captured_string+key&amp;#10;                #show it&amp;#10;                updateTheResponse(captured_string)&amp;#10;&amp;#10;#survey question 4&amp;#10;#!/usr/bin/env python&amp;#10;&amp;#10;# SUPPLIED WITH NO GUARANTEES!!&amp;#10;from psychopy import visual, core, event&amp;#10;#my lazy way of keeping time NB can be relatively inaccurate&amp;#10;import time &amp;#10;trialClock = core.Clock()&amp;#10;&amp;#10;# set up a stimulus window&amp;#10;win = visual.Window(size=(1366,768), fullscr=True,allowGUI=False,winType='pyglet',&amp;#10;            monitor='testMonitor', units ='deg', screen=0)&amp;#10;&amp;#10;#set up some fonts. If a list is provided, the first font found will be used.&amp;#10;sans = ['Gill Sans MT', 'Arial','Helvetica','Verdana']&amp;#10;&amp;#10;ResponseInstuction = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.5), text='Is there anything else you would like to tell us? Start typing and press return to continue.',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='white')&amp;#10;&amp;#10;#will be used to show the text they are typing: will update every &amp;#10;# time they type a letter&amp;#10;CapturedResponseString = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.07,&amp;#10;                        pos=(0, 0.0), text='',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='black')&amp;#10;&amp;#10;captured_string = '' #empty for now.. this is a string of zero length that &amp;#10;                                 # we will append our key presses to in sequence&amp;#10;&amp;#10;#a routine to save responses to file anytime we want to&amp;#10;def saveThisResponse(captured_string):&amp;#10;    outfile = &quot;./Data/visualEVENTSpauses/Surveys/%s_%s_SurveyResponses.tsv&quot; %(expInfo['participant'], expName)&amp;#10;    f = open(outfile, 'a') #open our results file in append mode so we don't overwrite anything&amp;#10;    f.write('%s \t' %expInfo['participant'])&amp;#10;    f.write('Question 4 \t')&amp;#10;    f.write('Is there anything else you would like to tell us? \t')&amp;#10;    f.write(captured_string) #write the string they typed&amp;#10;    f.write('\t')&amp;#10;    f.write('\n')&amp;#10;    f.close() #close and &quot;save&quot; the output file&amp;#10; &amp;#10;&amp;#10;#a routine to update the string on the screen as the participant types&amp;#10;def updateTheResponse(captured_string):&amp;#10;    CapturedResponseString.setText(captured_string)&amp;#10;    CapturedResponseString.draw()&amp;#10;    ResponseInstuction.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;#setup done, now start doing stuff&amp;#10;&amp;#10;# Create some handy timers&amp;#10;globalClock = core.Clock()  # to track the time since experiment started&amp;#10;routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine &amp;#10;&amp;#10;# ------Prepare to start Routine &quot;trial&quot;-------&amp;#10;t = 0&amp;#10;trialClock.reset()  # clock&amp;#10;frameN = -1&amp;#10;continueRoutine = True&amp;#10;# update component parameters for each repeat&amp;#10;&amp;#10;# keep track of which components have finished&amp;#10;trialComponents = []&amp;#10;for thisComponent in trialComponents:&amp;#10;    if hasattr(thisComponent, 'status'):&amp;#10;        thisComponent.status = NOT_STARTED&amp;#10;&amp;#10;# -------Start Routine &quot;trial&quot;-------&amp;#10;while continueRoutine:&amp;#10;    # get current time&amp;#10;    t = trialClock.getTime()&amp;#10;    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)&amp;#10;    # update/draw components on each frame&amp;#10;    &amp;#10;    &amp;#10;    # check if all components have finished&amp;#10;    if not continueRoutine:  # a component has requested a forced-end of Routine&amp;#10;        break&amp;#10;    continueRoutine = False  # will revert to True if at least one component still running&amp;#10;    for thisComponent in trialComponents:&amp;#10;        if hasattr(thisComponent, &quot;status&quot;) and thisComponent.status != FINISHED:&amp;#10;            continueRoutine = True&amp;#10;            break  # at least one component has not yet finished&amp;#10;&amp;#10;    # refresh the screen&amp;#10;    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen&amp;#10;        win.flip()&amp;#10;    #now instruct the participnat to respond&amp;#10;    ResponseInstuction.draw()  # draw instruction&amp;#10;    win.flip() # show instruction&amp;#10;    &amp;#10;    # now we will keep tracking what's happening on the keyboard&amp;#10;    # until the participant hits the return key&amp;#10;    subject_response_finished = 0 # only changes when they hit return&amp;#10;    &amp;#10;    #check for Esc key / return key presses each frame&amp;#10;    while subject_response_finished == 0:&amp;#10;        for key in event.getKeys():&amp;#10;            #quit at any point&amp;#10;            if key in ['escape']: &amp;#10;                win.close()&amp;#10;                core.quit()&amp;#10;                &amp;#10;            #if the participant hits return, save the string so far out &amp;#10;            #and reset the string to zero length for the next trial&amp;#10;            elif key in ['return']:&amp;#10;                print 'participant typed %s' %captured_string #show in debug window&amp;#10;                saveThisResponse(captured_string) #write to file&amp;#10;                captured_string = '' #reset to zero length &amp;#10;                subject_response_finished = 1 #allows the next trial to start&amp;#10;                &amp;#10;            #allow the participant to do deletions too , using the &amp;#10;            # delete key, and show the change they made&amp;#10;            elif key in ['delete','backspace']:&amp;#10;                captured_string = captured_string[:-1] #delete last character&amp;#10;                updateTheResponse(captured_string)&amp;#10;            #handle spaces&amp;#10;            elif key in ['space']:&amp;#10;                captured_string = captured_string+' '&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['period']:&amp;#10;                captured_string = captured_string+'.'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['comma']:&amp;#10;                captured_string = captured_string+','&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['apostrophe']:&amp;#10;                captured_string = captured_string+&quot;'&quot;&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['slash']:&amp;#10;                captured_string = captured_string+'/'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['semicolon']:&amp;#10;                captured_string = captured_string+';'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['bracketleft']:&amp;#10;                captured_string = captured_string+'['&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['bracketright']:&amp;#10;                captured_string = captured_string+']'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['minus']:&amp;#10;                captured_string = captured_string+'-'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['grave']:&amp;#10;                captured_string = captured_string+'`'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['equal']:&amp;#10;                captured_string = captured_string+'='&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['up','down','left','right','lshift','rshift','tab','capslock','lctrl','lalt','rctrl','ralt']:&amp;#10;                pass #do nothing when some keys are pressed&amp;#10;            #etc ...&amp;#10;&amp;#10;#if any other key is pressed, add it to the string and &amp;#10;            # show the participant what they typed&amp;#10;            else: &amp;#10;                captured_string = captured_string+key&amp;#10;                #show it&amp;#10;                updateTheResponse(captured_string)&amp;#10;&amp;#10;#survey endscreen&amp;#10;#i used the same code from the free response boxes, but got rid of all key responses except enter&amp;#10;#!/usr/bin/env python&amp;#10;&amp;#10;# SUPPLIED WITH NO GUARANTEES!!&amp;#10;from psychopy import visual, core, event&amp;#10;#my lazy way of keeping time NB can be relatively inaccurate&amp;#10;import time &amp;#10;trialClock = core.Clock()&amp;#10;&amp;#10;# set up a stimulus window&amp;#10;win = visual.Window(size=(1366,768), fullscr=True,allowGUI=False,winType='pyglet',&amp;#10;            monitor='testMonitor', units ='deg', screen=0)&amp;#10;&amp;#10;#set up some fonts. If a list is provided, the first font found will be used.&amp;#10;sans = ['Gill Sans MT', 'Arial','Helvetica','Verdana']&amp;#10;&amp;#10;ResponseInstuction = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0), text='Thank you for taking the survey! \n\nPlease let the experimenter know that you are finished.',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='white')&amp;#10;&amp;#10;#will be used to show the text they are typing: will update every &amp;#10;# time they type a letter&amp;#10;#nothing will actually show up for this one, participant just presses enter to advance&amp;#10;CapturedResponseString = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.0), text='',&amp;#10;                        font=sans, &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='white')&amp;#10;&amp;#10;captured_string = '' #empty for now.. this is a string of zero length that &amp;#10;                                 # we will append our key presses to in sequence&amp;#10; &amp;#10;&amp;#10;#a routine to update the string on the screen as the participant types&amp;#10;def updateTheResponse(captured_string):&amp;#10;    CapturedResponseString.setText(captured_string)&amp;#10;    CapturedResponseString.draw()&amp;#10;    ResponseInstuction.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;#setup done, now start doing stuff&amp;#10;&amp;#10;# Create some handy timers&amp;#10;globalClock = core.Clock()  # to track the time since experiment started&amp;#10;routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine &amp;#10;&amp;#10;# ------Prepare to start Routine &quot;trial&quot;-------&amp;#10;t = 0&amp;#10;trialClock.reset()  # clock&amp;#10;frameN = -1&amp;#10;continueRoutine = True&amp;#10;# update component parameters for each repeat&amp;#10;&amp;#10;# keep track of which components have finished&amp;#10;trialComponents = []&amp;#10;for thisComponent in trialComponents:&amp;#10;    if hasattr(thisComponent, 'status'):&amp;#10;        thisComponent.status = NOT_STARTED&amp;#10;&amp;#10;# -------Start Routine &quot;trial&quot;-------&amp;#10;while continueRoutine:&amp;#10;    # get current time&amp;#10;    t = trialClock.getTime()&amp;#10;    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)&amp;#10;    # update/draw components on each frame&amp;#10;    &amp;#10;    &amp;#10;    # check if all components have finished&amp;#10;    if not continueRoutine:  # a component has requested a forced-end of Routine&amp;#10;        break&amp;#10;    continueRoutine = False  # will revert to True if at least one component still running&amp;#10;    for thisComponent in trialComponents:&amp;#10;        if hasattr(thisComponent, &quot;status&quot;) and thisComponent.status != FINISHED:&amp;#10;            continueRoutine = True&amp;#10;            break  # at least one component has not yet finished&amp;#10;&amp;#10;    # refresh the screen&amp;#10;    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen&amp;#10;        win.flip()&amp;#10;    #now instruct the participnat to respond&amp;#10;    ResponseInstuction.draw()  # draw instruction&amp;#10;    win.flip() # show instruction&amp;#10;    &amp;#10;    # now we will keep tracking what's happening on the keyboard&amp;#10;    # until the participant hits the return key&amp;#10;    subject_response_finished = 0 # only changes when they hit return&amp;#10;    &amp;#10;    #check for Esc key / return key presses each frame&amp;#10;    while subject_response_finished == 0:&amp;#10;        for key in event.getKeys():&amp;#10;            #quit at any point&amp;#10;            if key in ['escape']: &amp;#10;                win.close()&amp;#10;                core.quit()" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
    </Routine>
    <Routine name="block9">
      <CodeComponent name="code_26">
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="name" updates="None" val="code_26" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="#M3N18P&amp;#10;&amp;#10;trialClock = core.Clock()&amp;#10;from psychopy import visual,event,core&amp;#10;import time&amp;#10;import sys&amp;#10;import random&amp;#10;import csv&amp;#10;import math&amp;#10;from numpy import linspace&amp;#10;&amp;#10;win = visual.Window(size=(1366,768), fullscr = True, units = 'pix', monitor = 'testMonitor', color = [.4,.7,1],&amp;#10;    colorSpace = &quot;rgb&quot;)&amp;#10;&amp;#10;square = visual.Rect(win, lineWidth=0, fillColor=&quot;red&quot;, size=[.2,.2], pos=[-.35,0], units=&quot;height&quot;)&amp;#10;&amp;#10;numframes = 140&amp;#10;framesArray = linspace(0,(1 * math.pi),numframes)&amp;#10;count = 0&amp;#10;motion = 0&amp;#10;cycle = 0&amp;#10;left = 0&amp;#10;pauses = random.sample(range(1, 9), 4)&amp;#10;print pauses&amp;#10;minimum = -.35&amp;#10;maximum = .35&amp;#10;while not cycle == 18:&amp;#10;    if count&gt;=(numframes):&amp;#10;        count = 0&amp;#10;        motion = 0&amp;#10;    x=framesArray[count]&amp;#10;    if ((.4 * math.tan(x)) + minimum) &gt; maximum: # CHANGE DIRECTIONS&amp;#10;        count = 0&amp;#10;        cycle += 1&amp;#10;        left += .5&amp;#10;        if left == pauses [0] or left == pauses[1] or left == pauses[2] or left == pauses[3]:&amp;#10;            time.sleep(.15)&amp;#10;        if motion == 0:&amp;#10;            motion = 1&amp;#10;            squarepos = maximum&amp;#10;        else:&amp;#10;            motion = 0&amp;#10;            squarepos = minimum&amp;#10;    elif motion == 1: # MOVING LEFT&amp;#10;        squarepos = maximum - (.4 * math.tan(x))&amp;#10;    else: #motion == 0 MOVING RIGHT&amp;#10;        squarepos = minimum + (.4 * math.tan(x))&amp;#10;    square.setPos([squarepos, 0])&amp;#10;    square.draw()&amp;#10;    win.flip()&amp;#10;    count += 1&amp;#10;    if (squarepos == minimum and cycle == 0) or (squarepos == minimum and cycle == 18):&amp;#10;        time.sleep(.15)&amp;#10;&amp;#10;order+=1" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
      <CodeComponent name="code_27">
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="name" updates="None" val="code_27" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="#!/usr/bin/env python&amp;#10;&amp;#10;# SUPPLIED WITH NO GUARANTEES!!&amp;#10;from psychopy import visual, core, event&amp;#10;#my lazy way of keeping time NB can be relatively inaccurate&amp;#10;import time &amp;#10;trialClock = core.Clock()&amp;#10;&amp;#10;# set up a stimulus window&amp;#10;win = visual.Window(size=(1366,768), fullscr=True,allowGUI=False,winType='pyglet',&amp;#10;            monitor='testMonitor', units ='deg', screen=0)&amp;#10;&amp;#10;#set up some fonts. If a list is provided, the first font found will be used.&amp;#10;sans = ['Gill Sans MT', 'Arial','Helvetica','Verdana']&amp;#10;&amp;#10;ResponseInstuction = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.5), text='What happened? Start typing and press return to continue.',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='white')&amp;#10;&amp;#10;#will be used to show the text they are typing: will update every &amp;#10;# time they type a letter&amp;#10;CapturedResponseString = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.07,&amp;#10;                        pos=(0, 0.0), text='',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='black')&amp;#10;&amp;#10;captured_string = '' #empty for now.. this is a string of zero length that &amp;#10;                                 # we will append our key presses to in sequence&amp;#10;&amp;#10;#a routine to save responses to file anytime we want to&amp;#10;def saveThisResponse(captured_string):&amp;#10;    outfile = &quot;./Data/visualEVENTSpauses/%s_%s_Responses.tsv&quot; %(expInfo['participant'], expName)&amp;#10;    f = open(outfile, 'a') #open our results file in append mode so we don't overwrite anything&amp;#10;    f.write('%s \t' %expInfo['participant'])&amp;#10;    f.write('%s' %order)&amp;#10;    f.write('\t')&amp;#10;    f.write('M3 \t')&amp;#10;    f.write('18 \t')&amp;#10;    f.write('1 \t')&amp;#10;    f.write('4 \t')&amp;#10;    f.write('%s' %pauses)&amp;#10;    f.write('\t')&amp;#10;    f.write(captured_string) #write the string they typed&amp;#10;    f.write('\t')&amp;#10;    f.close() #close and &quot;save&quot; the output file&amp;#10; &amp;#10;&amp;#10;#a routine to update the string on the screen as the participant types&amp;#10;def updateTheResponse(captured_string):&amp;#10;    CapturedResponseString.setText(captured_string)&amp;#10;    CapturedResponseString.draw()&amp;#10;    ResponseInstuction.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;#setup done, now start doing stuff&amp;#10;&amp;#10;# Create some handy timers&amp;#10;globalClock = core.Clock()  # to track the time since experiment started&amp;#10;routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine &amp;#10;&amp;#10;# ------Prepare to start Routine &quot;trial&quot;-------&amp;#10;t = 0&amp;#10;trialClock.reset()  # clock&amp;#10;frameN = -1&amp;#10;continueRoutine = True&amp;#10;# update component parameters for each repeat&amp;#10;&amp;#10;# keep track of which components have finished&amp;#10;trialComponents = []&amp;#10;for thisComponent in trialComponents:&amp;#10;    if hasattr(thisComponent, 'status'):&amp;#10;        thisComponent.status = NOT_STARTED&amp;#10;&amp;#10;# -------Start Routine &quot;trial&quot;-------&amp;#10;while continueRoutine:&amp;#10;    # get current time&amp;#10;    t = trialClock.getTime()&amp;#10;    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)&amp;#10;    # update/draw components on each frame&amp;#10;    &amp;#10;    &amp;#10;    # check if all components have finished&amp;#10;    if not continueRoutine:  # a component has requested a forced-end of Routine&amp;#10;        break&amp;#10;    continueRoutine = False  # will revert to True if at least one component still running&amp;#10;    for thisComponent in trialComponents:&amp;#10;        if hasattr(thisComponent, &quot;status&quot;) and thisComponent.status != FINISHED:&amp;#10;            continueRoutine = True&amp;#10;            break  # at least one component has not yet finished&amp;#10;&amp;#10;    # refresh the screen&amp;#10;    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen&amp;#10;        win.flip()&amp;#10;    #now instruct the participnat to respond&amp;#10;    ResponseInstuction.draw()  # draw instruction&amp;#10;    win.flip() # show instruction&amp;#10;    &amp;#10;    # now we will keep tracking what's happening on the keyboard&amp;#10;    # until the participant hits the return key&amp;#10;    subject_response_finished = 0 # only changes when they hit return&amp;#10;    &amp;#10;    #check for Esc key / return key presses each frame&amp;#10;    while subject_response_finished == 0:&amp;#10;        for key in event.getKeys():&amp;#10;            #quit at any point&amp;#10;            if key in ['escape']: &amp;#10;                win.close()&amp;#10;                core.quit()&amp;#10;                &amp;#10;            #if the participant hits return, save the string so far out &amp;#10;            #and reset the string to zero length for the next trial&amp;#10;            elif key in ['return']:&amp;#10;                print 'participant typed %s' %captured_string #show in debug window&amp;#10;                saveThisResponse(captured_string) #write to file&amp;#10;                captured_string = '' #reset to zero length &amp;#10;                subject_response_finished = 1 #allows the next trial to start&amp;#10;                &amp;#10;            #allow the participant to do deletions too , using the &amp;#10;            # delete key, and show the change they made&amp;#10;            elif key in ['delete','backspace']:&amp;#10;                captured_string = captured_string[:-1] #delete last character&amp;#10;                updateTheResponse(captured_string)&amp;#10;            #handle spaces&amp;#10;            elif key in ['space']:&amp;#10;                captured_string = captured_string+' '&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['period']:&amp;#10;                captured_string = captured_string+'.'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['comma']:&amp;#10;                captured_string = captured_string+','&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['apostrophe']:&amp;#10;                captured_string = captured_string+&quot;'&quot;&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['slash']:&amp;#10;                captured_string = captured_string+'/'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['semicolon']:&amp;#10;                captured_string = captured_string+';'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['bracketleft']:&amp;#10;                captured_string = captured_string+'['&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['bracketright']:&amp;#10;                captured_string = captured_string+']'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['minus']:&amp;#10;                captured_string = captured_string+'-'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['grave']:&amp;#10;                captured_string = captured_string+'`'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['equal']:&amp;#10;                captured_string = captured_string+'='&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['up','down','left','right','lshift','rshift','tab','capslock','lctrl','lalt','rctrl','ralt']:&amp;#10;                pass #do nothing when some keys are pressed&amp;#10;            #etc ...&amp;#10;&amp;#10;#if any other key is pressed, add it to the string and &amp;#10;            # show the participant what they typed&amp;#10;            else: &amp;#10;                captured_string = captured_string+key&amp;#10;                #show it&amp;#10;                updateTheResponse(captured_string)" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
      <CodeComponent name="code_28">
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="name" updates="None" val="code_28" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="#!/usr/bin/env python&amp;#10;&amp;#10;# SUPPLIED WITH NO GUARANTEES!!&amp;#10;from psychopy import visual, core, event&amp;#10;#my lazy way of keeping time NB can be relatively inaccurate&amp;#10;import time &amp;#10;&amp;#10;# set up a stimulus window&amp;#10;win = visual.Window(size=(1366,768), fullscr=True,allowGUI=False,winType='pyglet',&amp;#10;            monitor='testMonitor', units ='deg', screen=0)&amp;#10;&amp;#10;#set up some fonts. If a list is provided, the first font found will be used.&amp;#10;sans = ['Gill Sans MT', 'Arial','Helvetica','Verdana']&amp;#10;&amp;#10;ResponseInstuction = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.5), text='How many times? Please use the number keys at the top of the keyboard. Start typing and press return to continue.',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='white')&amp;#10;&amp;#10;#will be used to show the text they are typing: will update every &amp;#10;# time they type a letter&amp;#10;CapturedResponseString = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.0), text='',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='black')&amp;#10;&amp;#10;captured_string = '' #empty for now.. this is a string of zero length that &amp;#10;                                 # we will append our key presses to in sequence&amp;#10;&amp;#10;#a routine to save responses to file anytime we want to&amp;#10;def saveThisResponse(captured_string):&amp;#10;    outfile = &quot;./Data/visualEVENTSpauses/%s_%s_Responses.tsv&quot; %(expInfo['participant'], expName)&amp;#10;    f = open(outfile, 'a') #open our results file in append mode so we don't overwrite anything&amp;#10;    f.write(captured_string) #write the string they typed&amp;#10;    f.write('\n') # write a line ending&amp;#10;    f.close() #close and &quot;save&quot; the output file&amp;#10; &amp;#10;&amp;#10;#a routine to update the string on the screen as the participant types&amp;#10;def updateTheResponse(captured_string):&amp;#10;    CapturedResponseString.setText(captured_string)&amp;#10;    CapturedResponseString.draw()&amp;#10;    ResponseInstuction.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;#setup done, now start doing stuff&amp;#10;&amp;#10;# Create some handy timers&amp;#10;globalClock = core.Clock()  # to track the time since experiment started&amp;#10;routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine &amp;#10;&amp;#10;# ------Prepare to start Routine &quot;trial&quot;-------&amp;#10;t = 0&amp;#10;trialClock.reset()  # clock&amp;#10;frameN = -1&amp;#10;continueRoutine = True&amp;#10;# update component parameters for each repeat&amp;#10;&amp;#10;# keep track of which components have finished&amp;#10;trialComponents = []&amp;#10;for thisComponent in trialComponents:&amp;#10;    if hasattr(thisComponent, 'status'):&amp;#10;        thisComponent.status = NOT_STARTED&amp;#10;&amp;#10;# -------Start Routine &quot;trial&quot;-------&amp;#10;while continueRoutine:&amp;#10;    # get current time&amp;#10;    t = trialClock.getTime()&amp;#10;    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)&amp;#10;    # update/draw components on each frame&amp;#10;    &amp;#10;    &amp;#10;    # check if all components have finished&amp;#10;    if not continueRoutine:  # a component has requested a forced-end of Routine&amp;#10;        break&amp;#10;    continueRoutine = False  # will revert to True if at least one component still running&amp;#10;    for thisComponent in trialComponents:&amp;#10;        if hasattr(thisComponent, &quot;status&quot;) and thisComponent.status != FINISHED:&amp;#10;            continueRoutine = True&amp;#10;            break  # at least one component has not yet finished&amp;#10;&amp;#10;    # refresh the screen&amp;#10;    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen&amp;#10;        win.flip()&amp;#10;    #now instruct the participnat to respond&amp;#10;    ResponseInstuction.draw()  # draw instruction&amp;#10;    win.flip() # show instruction&amp;#10;    &amp;#10;    # now we will keep tracking what's happening on the keyboard&amp;#10;    # until the participant hits the return key&amp;#10;    subject_response_finished = 0 # only changes when they hit return&amp;#10;    &amp;#10;    #check for Esc key / return key presses each frame&amp;#10;    while subject_response_finished == 0:&amp;#10;        for key in event.getKeys():&amp;#10;            #quit at any point&amp;#10;            if key in ['escape']: &amp;#10;                win.close()&amp;#10;                core.quit()&amp;#10;                &amp;#10;            #if the participant hits return, save the string so far out &amp;#10;            #and reset the string to zero length for the next trial&amp;#10;            elif key in ['return']:&amp;#10;                print 'participant typed %s' %captured_string #show in debug window&amp;#10;                saveThisResponse(captured_string) #write to file&amp;#10;                captured_string = '' #reset to zero length &amp;#10;                subject_response_finished = 1 #allows the next trial to start&amp;#10;                &amp;#10;            #allow the participant to do deletions too , using the &amp;#10;            # delete key, and show the change they made&amp;#10;            elif key in ['delete','backspace']:&amp;#10;                captured_string = captured_string[:-1] #delete last character&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['up','down','left','right','lshift','rshift','tab','capslock','lctrl','lalt','rctrl','ralt', 'space', 'period', 'comma', 'apostrophe', 'slash', 'semicolon', 'bracketleft', 'bracketright', 'minus', 'grave', 'equal', 'tab', 'capslock', 'alt', 'control', 'backlash', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'z', 'x', 'c', 'v', 'b', 'n', 'm']:&amp;#10;                pass #do nothing when some keys are pressed&amp;#10;            #etc ...&amp;#10;&amp;#10;#if any other key is pressed, add it to the string and &amp;#10;            # show the participant what they typed&amp;#10;            else: &amp;#10;                captured_string = captured_string+key&amp;#10;                #show it&amp;#10;                updateTheResponse(captured_string)" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
    </Routine>
    <Routine name="block8">
      <CodeComponent name="code_23">
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="name" updates="None" val="code_23" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="#M3N10P&amp;#10;&amp;#10;trialClock = core.Clock()&amp;#10;from psychopy import visual,event,core&amp;#10;import time&amp;#10;import sys&amp;#10;import random&amp;#10;import csv&amp;#10;import math&amp;#10;from numpy import linspace&amp;#10;&amp;#10;win = visual.Window(size=(1366,768), fullscr = True, units = 'pix', monitor = 'testMonitor', color = [.4,.7,1],&amp;#10;    colorSpace = &quot;rgb&quot;)&amp;#10;&amp;#10;square = visual.Rect(win, lineWidth=0, fillColor=&quot;red&quot;, size=[.2,.2], pos=[-.35,0], units=&quot;height&quot;)&amp;#10;&amp;#10;numframes = 140&amp;#10;framesArray = linspace(0,(1 * math.pi),numframes)&amp;#10;count = 0&amp;#10;motion = 0&amp;#10;cycle = 0&amp;#10;left = 0&amp;#10;pauses = random.sample(range(1, 5), 2)&amp;#10;minimum = -.35&amp;#10;maximum = .35&amp;#10;while not cycle == 10:&amp;#10;    if count&gt;=(numframes):&amp;#10;        count = 0&amp;#10;        motion = 0&amp;#10;    x=framesArray[count]&amp;#10;    if ((.4 * math.tan(x)) + minimum) &gt; maximum: # CHANGE DIRECTIONS&amp;#10;        count = 0&amp;#10;        cycle += 1&amp;#10;        left += .5&amp;#10;        if left == pauses [0] or left == pauses[1]:&amp;#10;            time.sleep(.15)&amp;#10;        if motion == 0:&amp;#10;            motion = 1&amp;#10;            squarepos = maximum&amp;#10;        else:&amp;#10;            motion = 0&amp;#10;            squarepos = minimum&amp;#10;    elif motion == 1: # MOVING LEFT&amp;#10;        squarepos = maximum - (.4 * math.tan(x))&amp;#10;    else: #motion == 0 MOVING RIGHT&amp;#10;        squarepos = minimum + (.4 * math.tan(x))&amp;#10;    square.setPos([squarepos, 0])&amp;#10;    square.draw()&amp;#10;    win.flip()&amp;#10;    count += 1&amp;#10;    if (squarepos == minimum and cycle == 0) or (squarepos == minimum and cycle == 10):&amp;#10;        time.sleep(.15)&amp;#10;&amp;#10;order+=1" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
      <CodeComponent name="code_24">
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="name" updates="None" val="code_24" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="#!/usr/bin/env python&amp;#10;&amp;#10;# SUPPLIED WITH NO GUARANTEES!!&amp;#10;from psychopy import visual, core, event&amp;#10;#my lazy way of keeping time NB can be relatively inaccurate&amp;#10;import time &amp;#10;trialClock = core.Clock()&amp;#10;&amp;#10;# set up a stimulus window&amp;#10;win = visual.Window(size=(1366,768), fullscr=True,allowGUI=False,winType='pyglet',&amp;#10;            monitor='testMonitor', units ='deg', screen=0)&amp;#10;&amp;#10;#set up some fonts. If a list is provided, the first font found will be used.&amp;#10;sans = ['Gill Sans MT', 'Arial','Helvetica','Verdana']&amp;#10;&amp;#10;ResponseInstuction = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.5), text='What happened? Start typing and press return to continue.',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='white')&amp;#10;&amp;#10;#will be used to show the text they are typing: will update every &amp;#10;# time they type a letter&amp;#10;CapturedResponseString = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.07,&amp;#10;                        pos=(0, 0.0), text='',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='black')&amp;#10;&amp;#10;captured_string = '' #empty for now.. this is a string of zero length that &amp;#10;                                 # we will append our key presses to in sequence&amp;#10;&amp;#10;#a routine to save responses to file anytime we want to&amp;#10;def saveThisResponse(captured_string):&amp;#10;    outfile = &quot;./Data/visualEVENTSpauses/%s_%s_Responses.tsv&quot; %(expInfo['participant'], expName)&amp;#10;    f = open(outfile, 'a') #open our results file in append mode so we don't overwrite anything&amp;#10;    f.write('%s \t' %expInfo['participant'])&amp;#10;    f.write('%s' %order)&amp;#10;    f.write('\t')&amp;#10;    f.write('M3 \t')&amp;#10;    f.write('10 \t')&amp;#10;    f.write('1 \t')&amp;#10;    f.write('2 \t')&amp;#10;    f.write('%s' %pauses)&amp;#10;    f.write('\t')&amp;#10;    f.write(captured_string) #write the string they typed&amp;#10;    f.write('\t')&amp;#10;    f.close() #close and &quot;save&quot; the output file&amp;#10; &amp;#10;&amp;#10;#a routine to update the string on the screen as the participant types&amp;#10;def updateTheResponse(captured_string):&amp;#10;    CapturedResponseString.setText(captured_string)&amp;#10;    CapturedResponseString.draw()&amp;#10;    ResponseInstuction.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;#setup done, now start doing stuff&amp;#10;&amp;#10;# Create some handy timers&amp;#10;globalClock = core.Clock()  # to track the time since experiment started&amp;#10;routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine &amp;#10;&amp;#10;# ------Prepare to start Routine &quot;trial&quot;-------&amp;#10;t = 0&amp;#10;trialClock.reset()  # clock&amp;#10;frameN = -1&amp;#10;continueRoutine = True&amp;#10;# update component parameters for each repeat&amp;#10;&amp;#10;# keep track of which components have finished&amp;#10;trialComponents = []&amp;#10;for thisComponent in trialComponents:&amp;#10;    if hasattr(thisComponent, 'status'):&amp;#10;        thisComponent.status = NOT_STARTED&amp;#10;&amp;#10;# -------Start Routine &quot;trial&quot;-------&amp;#10;while continueRoutine:&amp;#10;    # get current time&amp;#10;    t = trialClock.getTime()&amp;#10;    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)&amp;#10;    # update/draw components on each frame&amp;#10;    &amp;#10;    &amp;#10;    # check if all components have finished&amp;#10;    if not continueRoutine:  # a component has requested a forced-end of Routine&amp;#10;        break&amp;#10;    continueRoutine = False  # will revert to True if at least one component still running&amp;#10;    for thisComponent in trialComponents:&amp;#10;        if hasattr(thisComponent, &quot;status&quot;) and thisComponent.status != FINISHED:&amp;#10;            continueRoutine = True&amp;#10;            break  # at least one component has not yet finished&amp;#10;&amp;#10;    # refresh the screen&amp;#10;    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen&amp;#10;        win.flip()&amp;#10;    #now instruct the participnat to respond&amp;#10;    ResponseInstuction.draw()  # draw instruction&amp;#10;    win.flip() # show instruction&amp;#10;    &amp;#10;    # now we will keep tracking what's happening on the keyboard&amp;#10;    # until the participant hits the return key&amp;#10;    subject_response_finished = 0 # only changes when they hit return&amp;#10;    &amp;#10;    #check for Esc key / return key presses each frame&amp;#10;    while subject_response_finished == 0:&amp;#10;        for key in event.getKeys():&amp;#10;            #quit at any point&amp;#10;            if key in ['escape']: &amp;#10;                win.close()&amp;#10;                core.quit()&amp;#10;                &amp;#10;            #if the participant hits return, save the string so far out &amp;#10;            #and reset the string to zero length for the next trial&amp;#10;            elif key in ['return']:&amp;#10;                print 'participant typed %s' %captured_string #show in debug window&amp;#10;                saveThisResponse(captured_string) #write to file&amp;#10;                captured_string = '' #reset to zero length &amp;#10;                subject_response_finished = 1 #allows the next trial to start&amp;#10;                &amp;#10;            #allow the participant to do deletions too , using the &amp;#10;            # delete key, and show the change they made&amp;#10;            elif key in ['delete','backspace']:&amp;#10;                captured_string = captured_string[:-1] #delete last character&amp;#10;                updateTheResponse(captured_string)&amp;#10;            #handle spaces&amp;#10;            elif key in ['space']:&amp;#10;                captured_string = captured_string+' '&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['period']:&amp;#10;                captured_string = captured_string+'.'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['comma']:&amp;#10;                captured_string = captured_string+','&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['apostrophe']:&amp;#10;                captured_string = captured_string+&quot;'&quot;&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['slash']:&amp;#10;                captured_string = captured_string+'/'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['semicolon']:&amp;#10;                captured_string = captured_string+';'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['bracketleft']:&amp;#10;                captured_string = captured_string+'['&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['bracketright']:&amp;#10;                captured_string = captured_string+']'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['minus']:&amp;#10;                captured_string = captured_string+'-'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['grave']:&amp;#10;                captured_string = captured_string+'`'&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['equal']:&amp;#10;                captured_string = captured_string+'='&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['up','down','left','right','lshift','rshift','tab','capslock','lctrl','lalt','rctrl','ralt']:&amp;#10;                pass #do nothing when some keys are pressed&amp;#10;            #etc ...&amp;#10;#if any other key is pressed, add it to the string and &amp;#10;            # show the participant what they typed&amp;#10;            else: &amp;#10;                captured_string = captured_string+key&amp;#10;                #show it&amp;#10;                updateTheResponse(captured_string)" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
      <CodeComponent name="code_25">
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="name" updates="None" val="code_25" valType="code"/>
        <Param name="Begin Routine" updates="constant" val="#!/usr/bin/env python&amp;#10;&amp;#10;# SUPPLIED WITH NO GUARANTEES!!&amp;#10;from psychopy import visual, core, event&amp;#10;#my lazy way of keeping time NB can be relatively inaccurate&amp;#10;import time &amp;#10;&amp;#10;# set up a stimulus window&amp;#10;win = visual.Window(size=(1366,768), fullscr=True,allowGUI=False,winType='pyglet',&amp;#10;            monitor='testMonitor', units ='deg', screen=0)&amp;#10;&amp;#10;#set up some fonts. If a list is provided, the first font found will be used.&amp;#10;sans = ['Gill Sans MT', 'Arial','Helvetica','Verdana']&amp;#10;&amp;#10;ResponseInstuction = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.5), text='How many times? Please use the number keys at the top of the keyboard. Start typing and press return to continue.',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='white')&amp;#10;&amp;#10;#will be used to show the text they are typing: will update every &amp;#10;# time they type a letter&amp;#10;CapturedResponseString = visual.TextStim(win, &amp;#10;                        units='norm',height = 0.1,&amp;#10;                        pos=(0, 0.0), text='',&amp;#10;                        font='Arial', &amp;#10;                        alignHoriz = 'center',alignVert='center',&amp;#10;                        color='black')&amp;#10;&amp;#10;captured_string = '' #empty for now.. this is a string of zero length that &amp;#10;                                 # we will append our key presses to in sequence&amp;#10;&amp;#10;#a routine to save responses to file anytime we want to&amp;#10;def saveThisResponse(captured_string):&amp;#10;    outfile = &quot;./Data/visualEVENTSpauses/%s_%s_Responses.tsv&quot; %(expInfo['participant'], expName)&amp;#10;    f = open(outfile, 'a') #open our results file in append mode so we don't overwrite anything&amp;#10;    f.write(captured_string) #write the string they typed&amp;#10;    f.write('\n') # write a line ending&amp;#10;    f.close() #close and &quot;save&quot; the output file&amp;#10; &amp;#10;&amp;#10;#a routine to update the string on the screen as the participant types&amp;#10;def updateTheResponse(captured_string):&amp;#10;    CapturedResponseString.setText(captured_string)&amp;#10;    CapturedResponseString.draw()&amp;#10;    ResponseInstuction.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;#setup done, now start doing stuff&amp;#10;&amp;#10;# Create some handy timers&amp;#10;globalClock = core.Clock()  # to track the time since experiment started&amp;#10;routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine &amp;#10;&amp;#10;# ------Prepare to start Routine &quot;trial&quot;-------&amp;#10;t = 0&amp;#10;trialClock.reset()  # clock&amp;#10;frameN = -1&amp;#10;continueRoutine = True&amp;#10;# update component parameters for each repeat&amp;#10;&amp;#10;# keep track of which components have finished&amp;#10;trialComponents = []&amp;#10;for thisComponent in trialComponents:&amp;#10;    if hasattr(thisComponent, 'status'):&amp;#10;        thisComponent.status = NOT_STARTED&amp;#10;&amp;#10;# -------Start Routine &quot;trial&quot;-------&amp;#10;while continueRoutine:&amp;#10;    # get current time&amp;#10;    t = trialClock.getTime()&amp;#10;    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)&amp;#10;    # update/draw components on each frame&amp;#10;    &amp;#10;    &amp;#10;    # check if all components have finished&amp;#10;    if not continueRoutine:  # a component has requested a forced-end of Routine&amp;#10;        break&amp;#10;    continueRoutine = False  # will revert to True if at least one component still running&amp;#10;    for thisComponent in trialComponents:&amp;#10;        if hasattr(thisComponent, &quot;status&quot;) and thisComponent.status != FINISHED:&amp;#10;            continueRoutine = True&amp;#10;            break  # at least one component has not yet finished&amp;#10;&amp;#10;    # refresh the screen&amp;#10;    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen&amp;#10;        win.flip()&amp;#10;    #now instruct the participnat to respond&amp;#10;    ResponseInstuction.draw()  # draw instruction&amp;#10;    win.flip() # show instruction&amp;#10;    &amp;#10;    # now we will keep tracking what's happening on the keyboard&amp;#10;    # until the participant hits the return key&amp;#10;    subject_response_finished = 0 # only changes when they hit return&amp;#10;    &amp;#10;    #check for Esc key / return key presses each frame&amp;#10;    while subject_response_finished == 0:&amp;#10;        for key in event.getKeys():&amp;#10;            #quit at any point&amp;#10;            if key in ['escape']: &amp;#10;                win.close()&amp;#10;                core.quit()&amp;#10;                &amp;#10;            #if the participant hits return, save the string so far out &amp;#10;            #and reset the string to zero length for the next trial&amp;#10;            elif key in ['return']:&amp;#10;                print 'participant typed %s' %captured_string #show in debug window&amp;#10;                saveThisResponse(captured_string) #write to file&amp;#10;                captured_string = '' #reset to zero length &amp;#10;                subject_response_finished = 1 #allows the next trial to start&amp;#10;                &amp;#10;            #allow the participant to do deletions too , using the &amp;#10;            # delete key, and show the change they made&amp;#10;            elif key in ['delete','backspace']:&amp;#10;                captured_string = captured_string[:-1] #delete last character&amp;#10;                updateTheResponse(captured_string)&amp;#10;            elif key in ['up','down','left','right','lshift','rshift','tab','capslock','lctrl','lalt','rctrl','ralt', 'space', 'period', 'comma', 'apostrophe', 'slash', 'semicolon', 'bracketleft', 'bracketright', 'minus', 'grave', 'equal', 'tab', 'capslock', 'alt', 'control', 'backlash', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'z', 'x', 'c', 'v', 'b', 'n', 'm']:&amp;#10;                pass #do nothing when some keys are pressed&amp;#10;            #etc ...&amp;#10;&amp;#10;#if any other key is pressed, add it to the string and &amp;#10;            # show the participant what they typed&amp;#10;            else: &amp;#10;                captured_string = captured_string+key&amp;#10;                #show it&amp;#10;                updateTheResponse(captured_string)" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
      </CodeComponent>
    </Routine>
  </Routines>
  <Flow>
    <Routine name="instr"/>
    <LoopInitiator loopType="TrialHandler" name="blockSelectLoop">
      <Param name="conditionsFile" updates="None" val="blockSelect.xlsx" valType="str"/>
      <Param name="name" updates="None" val="blockSelectLoop" valType="code"/>
      <Param name="isTrials" updates="None" val="True" valType="bool"/>
      <Param name="random seed" updates="None" val="" valType="code"/>
      <Param name="loopType" updates="None" val="random" valType="str"/>
      <Param name="nReps" updates="None" val="1" valType="code"/>
      <Param name="endPoints" updates="None" val="[0, 1]" valType="num"/>
      <Param name="conditions" updates="None" val="[{u'selectBlock': 9L}, {u'selectBlock': 8L}, {u'selectBlock': 7L}, {u'selectBlock': 6L}, {u'selectBlock': 5L}, {u'selectBlock': 4L}, {u'selectBlock': 3L}, {u'selectBlock': 2L}, {u'selectBlock': 1L}]" valType="str"/>
      <Param name="Selected rows" updates="None" val="" valType="str"/>
    </LoopInitiator>
    <Routine name="blockSelect"/>
    <LoopInitiator loopType="TrialHandler" name="block1Loop">
      <Param name="conditionsFile" updates="None" val="" valType="str"/>
      <Param name="name" updates="None" val="block1Loop" valType="code"/>
      <Param name="isTrials" updates="None" val="True" valType="bool"/>
      <Param name="random seed" updates="None" val="" valType="code"/>
      <Param name="loopType" updates="None" val="random" valType="str"/>
      <Param name="nReps" updates="None" val="nRepsblock1" valType="code"/>
      <Param name="endPoints" updates="None" val="[0, 1]" valType="num"/>
      <Param name="conditions" updates="None" val="None" valType="str"/>
      <Param name="Selected rows" updates="None" val="" valType="str"/>
    </LoopInitiator>
    <Routine name="block1"/>
    <LoopTerminator name="block1Loop"/>
    <LoopInitiator loopType="TrialHandler" name="block2Loop">
      <Param name="conditionsFile" updates="None" val="" valType="str"/>
      <Param name="name" updates="None" val="block2Loop" valType="code"/>
      <Param name="isTrials" updates="None" val="True" valType="bool"/>
      <Param name="random seed" updates="None" val="" valType="code"/>
      <Param name="loopType" updates="None" val="random" valType="str"/>
      <Param name="nReps" updates="None" val="nRepsblock2" valType="code"/>
      <Param name="endPoints" updates="None" val="[0, 1]" valType="num"/>
      <Param name="conditions" updates="None" val="None" valType="str"/>
      <Param name="Selected rows" updates="None" val="" valType="str"/>
    </LoopInitiator>
    <Routine name="block2"/>
    <LoopTerminator name="block2Loop"/>
    <LoopInitiator loopType="TrialHandler" name="block3Loop">
      <Param name="conditionsFile" updates="None" val="" valType="str"/>
      <Param name="name" updates="None" val="block3Loop" valType="code"/>
      <Param name="isTrials" updates="None" val="True" valType="bool"/>
      <Param name="random seed" updates="None" val="" valType="code"/>
      <Param name="loopType" updates="None" val="random" valType="str"/>
      <Param name="nReps" updates="None" val="nRepsblock3" valType="code"/>
      <Param name="endPoints" updates="None" val="[0, 1]" valType="num"/>
      <Param name="conditions" updates="None" val="None" valType="str"/>
      <Param name="Selected rows" updates="None" val="" valType="str"/>
    </LoopInitiator>
    <Routine name="block3"/>
    <LoopTerminator name="block3Loop"/>
    <LoopInitiator loopType="TrialHandler" name="block4Loop">
      <Param name="conditionsFile" updates="None" val="" valType="str"/>
      <Param name="name" updates="None" val="block4Loop" valType="code"/>
      <Param name="isTrials" updates="None" val="True" valType="bool"/>
      <Param name="random seed" updates="None" val="" valType="code"/>
      <Param name="loopType" updates="None" val="random" valType="str"/>
      <Param name="nReps" updates="None" val="nRepsblock4" valType="code"/>
      <Param name="endPoints" updates="None" val="[0, 1]" valType="num"/>
      <Param name="conditions" updates="None" val="None" valType="str"/>
      <Param name="Selected rows" updates="None" val="" valType="str"/>
    </LoopInitiator>
    <Routine name="block4"/>
    <LoopTerminator name="block4Loop"/>
    <LoopInitiator loopType="TrialHandler" name="block5Loop">
      <Param name="conditionsFile" updates="None" val="" valType="str"/>
      <Param name="name" updates="None" val="block5Loop" valType="code"/>
      <Param name="isTrials" updates="None" val="True" valType="bool"/>
      <Param name="random seed" updates="None" val="" valType="code"/>
      <Param name="loopType" updates="None" val="random" valType="str"/>
      <Param name="nReps" updates="None" val="nRepsblock5" valType="code"/>
      <Param name="endPoints" updates="None" val="[0, 1]" valType="num"/>
      <Param name="conditions" updates="None" val="None" valType="str"/>
      <Param name="Selected rows" updates="None" val="" valType="str"/>
    </LoopInitiator>
    <Routine name="block5"/>
    <LoopTerminator name="block5Loop"/>
    <LoopInitiator loopType="TrialHandler" name="block6Loop">
      <Param name="conditionsFile" updates="None" val="" valType="str"/>
      <Param name="name" updates="None" val="block6Loop" valType="code"/>
      <Param name="isTrials" updates="None" val="True" valType="bool"/>
      <Param name="random seed" updates="None" val="" valType="code"/>
      <Param name="loopType" updates="None" val="random" valType="str"/>
      <Param name="nReps" updates="None" val="nRepsblock6" valType="code"/>
      <Param name="endPoints" updates="None" val="[0, 1]" valType="num"/>
      <Param name="conditions" updates="None" val="None" valType="str"/>
      <Param name="Selected rows" updates="None" val="" valType="str"/>
    </LoopInitiator>
    <Routine name="block6"/>
    <LoopTerminator name="block6Loop"/>
    <LoopInitiator loopType="TrialHandler" name="block7Loop">
      <Param name="conditionsFile" updates="None" val="" valType="str"/>
      <Param name="name" updates="None" val="block7Loop" valType="code"/>
      <Param name="isTrials" updates="None" val="True" valType="bool"/>
      <Param name="random seed" updates="None" val="" valType="code"/>
      <Param name="loopType" updates="None" val="random" valType="str"/>
      <Param name="nReps" updates="None" val="nRepsblock7" valType="code"/>
      <Param name="endPoints" updates="None" val="[0, 1]" valType="num"/>
      <Param name="conditions" updates="None" val="None" valType="str"/>
      <Param name="Selected rows" updates="None" val="" valType="str"/>
    </LoopInitiator>
    <Routine name="block7"/>
    <LoopTerminator name="block7Loop"/>
    <LoopInitiator loopType="TrialHandler" name="block8Loop">
      <Param name="conditionsFile" updates="None" val="" valType="str"/>
      <Param name="name" updates="None" val="block8Loop" valType="code"/>
      <Param name="isTrials" updates="None" val="True" valType="bool"/>
      <Param name="random seed" updates="None" val="" valType="code"/>
      <Param name="loopType" updates="None" val="random" valType="str"/>
      <Param name="nReps" updates="None" val="nRepsblock8" valType="code"/>
      <Param name="endPoints" updates="None" val="[0, 1]" valType="num"/>
      <Param name="conditions" updates="None" val="None" valType="str"/>
      <Param name="Selected rows" updates="None" val="" valType="str"/>
    </LoopInitiator>
    <Routine name="block8"/>
    <LoopTerminator name="block8Loop"/>
    <LoopInitiator loopType="TrialHandler" name="block9Loop">
      <Param name="conditionsFile" updates="None" val="" valType="str"/>
      <Param name="name" updates="None" val="block9Loop" valType="code"/>
      <Param name="isTrials" updates="None" val="True" valType="bool"/>
      <Param name="random seed" updates="None" val="" valType="code"/>
      <Param name="loopType" updates="None" val="random" valType="str"/>
      <Param name="nReps" updates="None" val="nRepsblock9" valType="code"/>
      <Param name="endPoints" updates="None" val="[0, 1]" valType="num"/>
      <Param name="conditions" updates="None" val="None" valType="str"/>
      <Param name="Selected rows" updates="None" val="" valType="str"/>
    </LoopInitiator>
    <Routine name="block9"/>
    <LoopTerminator name="block9Loop"/>
    <LoopTerminator name="blockSelectLoop"/>
  </Flow>
</PsychoPy2experiment>
